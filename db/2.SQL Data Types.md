# SQL Data Types - Complete Knowledge Base

## 🎯 **NUMERIC DATA TYPES**

### **Core Knowledge Base**

#### **INT Types**
```sql
-- Integer types with storage sizes
TINYINT      -- 1 byte (0 to 255)
SMALLINT     -- 2 bytes (-32,768 to 32,767)
INT          -- 4 bytes (-2^31 to 2^31-1)
BIGINT       -- 8 bytes (-2^63 to 2^63-1)
```

#### **DECIMAL/NUMERIC**
```sql
DECIMAL(10, 2)  -- Precision 10, Scale 2
NUMERIC(8, 4)   -- Same as DECIMAL
-- Precision = total digits, Scale = decimal places
```

#### **FLOAT/REAL**
```sql
FLOAT(24)       -- 4 bytes (7-digit precision)
FLOAT(53)       -- 8 bytes (15-digit precision)
REAL            -- Same as FLOAT(24)
```

### **Corner Cases & Tricky Questions**

#### **Question 1: Integer Overflow**
**Question:** "What happens when you try to store 300 in a TINYINT column?"

**Answer:** 
- **SQL Server:** Arithmetic overflow error
- **MySQL:** Stores 255 (max value) with warning
- **PostgreSQL:** Error - value out of range

**What Interviewer Seeks:** Understanding of data type limits and error handling.

#### **Question 2: DECIMAL Precision**
**Question:** "You have DECIMAL(5,2). What values can it store? What about 1234.56?"

**Answer:**
- Valid: 123.45, 999.99, -999.99
- Invalid: 1234.56 (exceeds precision)
- **Reasoning:** 5 total digits, 2 decimal places = max 3 integer digits

**Follow-up:** "What's the storage difference between DECIMAL(10,2) and DECIMAL(10,4)?"
**Answer:** Same storage! Scale affects range, not storage size.

#### **Question 3: FLOAT Precision Issues**
**Question:** "Why should you avoid FLOAT for financial calculations?"

**Answer:** 
```sql
-- Demonstration of floating point error
SELECT (0.1 + 0.2) as FloatResult,  -- Returns 0.30000000000000004
       0.3 as ExpectedResult;        -- Returns 0.3
```
**Reasoning:** Floating-point numbers are approximate; use DECIMAL for exact arithmetic.

### **Common Patterns**

#### **Pattern 1: Choosing the Right Integer Type**
```sql
-- User Age: TINYINT (0-255 sufficient)
-- Product Quantity: INT (handles large inventories)
-- Database ID: BIGINT (future-proof for large datasets)
-- Status Flags: TINYINT (1, 0, -1 for states)
```

#### **Pattern 2: Financial Calculations**
```sql
-- Always use DECIMAL for money
CREATE TABLE Transactions (
    Amount DECIMAL(15, 2),  -- Handles up to 9 trillion
    Tax DECIMAL(10, 4)      -- High precision for percentages
);
```

#### **Pattern 3: Scientific Data**
```sql
-- Use FLOAT for scientific measurements
CREATE SensorReadings (
    Temperature FLOAT,      -- Approximate values OK
    PrecisionMeasurement DECIMAL(8, 6)  -- High precision needed
);
```

---

## 📝 **CHARACTER DATA TYPES**

### **Core Knowledge Base**

#### **Fixed vs Variable Length**
```sql
CHAR(10)      -- Fixed length, pads with spaces
VARCHAR(10)   -- Variable length, no padding
NCHAR(10)     -- Unicode fixed length
NVARCHAR(10)  -- Unicode variable length
TEXT          -- Large text (deprecated in some DBs)
NTEXT         -- Large Unicode text
```

### **Corner Cases & Tricky Questions**

#### **Question 1: CHAR vs VARCHAR Storage**
**Question:** "When would you use CHAR over VARCHAR?"

**Answer:**
- **CHAR:** Fixed-length data (codes, flags, phone numbers)
- **VARCHAR:** Variable-length data (names, addresses)

**Example:**
```sql
-- CHAR is better for fixed-length codes
CountryCode CHAR(2)        -- 'US', 'UK' (always 2 chars)
FirstName VARCHAR(50)      -- 'John' (variable length)
```

**What Interviewer Seeks:** Understanding of storage optimization.

#### **Question 2: Collation and Sorting**
**Question:** "What's the difference between these queries?"
```sql
SELECT * FROM Users WHERE Name = 'john'
SELECT * FROM Users WHERE Name = 'JOHN'
```

**Answer:** Depends on collation! 
- Case-sensitive: Different results
- Case-insensitive: Same results

**Follow-up:** "How to make a column case-sensitive?"
```sql
CREATE TABLE Users (
    Name VARCHAR(50) COLLATE SQL_Latin1_General_CP1_CS_AS
);
```

#### **Question 3: Unicode Storage Overhead**
**Question:** "Why does NVARCHAR use more storage than VARCHAR?"

**Answer:** 
- VARCHAR: 1 byte per character (ASCII)
- NVARCHAR: 2 bytes per character (Unicode)
- **Example:** 'Hello' = 5 bytes vs 10 bytes

### **Common Patterns**

#### **Pattern 1: Email Validation Storage**
```sql
CREATE TABLE Users (
    Email VARCHAR(254)  -- RFC 5321 maximum length
);
```

#### **Pattern 2: Multi-language Support**
```sql
-- For international applications
CREATE Products (
    Name NVARCHAR(100),     -- Supports any language
    Description NTEXT       -- Large Unicode content
);
```

#### **Pattern 3: Performance Optimization**
```sql
-- Use CHAR for fixed-length codes
CREATE TABLE Countries (
    Code CHAR(2) PRIMARY KEY,    -- Fixed length = faster joins
    Name NVARCHAR(50)
);
```

---

## 📅 **DATE/TIME DATA TYPES**

### **Core Knowledge Base**

#### **Date/Time Types**
```sql
DATE          -- Date only (YYYY-MM-DD)
TIME          -- Time only (HH:MM:SS)
DATETIME      -- Date + Time (SQL Server)
DATETIME2     -- Higher precision (SQL Server)
TIMESTAMP     -- Auto-updating, timezone-aware
SMALLDATETIME -- Lower precision, less storage
```

### **Corner Cases & Tricky Questions**

#### **Question 1: Timezone Handling**
**Question:** "How do you store timestamps for a global application?"

**Answer:** 
```sql
-- Option 1: Store in UTC
CreatedAt DATETIMEOFFSET  -- Includes timezone offset
-- Option 2: Store UTC time
CreatedAt DATETIME2       -- Always store as UTC
```

**Reasoning:** Avoid timezone confusion; convert to local time in application.

#### **Question 2: DATETIME vs DATETIME2**
**Question:** "When would you choose DATETIME2 over DATETIME?"

**Answer:**
- **DATETIME:** 1753-9999 range, 3.33ms precision
- **DATETIME2:** 0001-9999 range, 100ns precision
- **Use DATETIME2 for:** Scientific data, high-frequency logging

#### **Question 3: Year 2038 Problem**
**Question:** "What's the Year 2038 problem with TIMESTAMP?"

**Answer:** 
- MySQL TIMESTAMP ends at 2038-01-19 (32-bit limitation)
- Solution: Use DATETIME for dates beyond 2038

### **Common Patterns**

#### **Pattern 1: Audit Fields**
```sql
CREATE TABLE Orders (
    Id INT PRIMARY KEY,
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    UpdatedAt DATETIME2 DEFAULT GETDATE()
);

-- Trigger for UpdatedAt
CREATE TRIGGER UpdateTimestamp 
ON Orders AFTER UPDATE AS
UPDATE Orders SET UpdatedAt = GETDATE()
WHERE Id IN (SELECT Id FROM inserted);
```

#### **Pattern 2: Date Range Queries**
```sql
-- Efficient date filtering
SELECT * FROM Orders 
WHERE OrderDate >= '2024-01-01' 
  AND OrderDate < '2024-02-01';  -- Better than BETWEEN for indexes
```

#### **Pattern 3: Age Calculations**
```sql
-- Calculate age accurately
SELECT DATEDIFF(YEAR, BirthDate, GETDATE()) -
    CASE WHEN DATEADD(YEAR, DATEDIFF(YEAR, BirthDate, GETDATE()), BirthDate) > GETDATE()
         THEN 1 ELSE 0 END as AccurateAge;
```

---

## ⚡ **BOOLEAN TYPE**

### **Core Knowledge Base**

#### **Boolean Implementation**
```sql
-- SQL Server
BIT           -- 0 or 1 (can store NULL)
-- PostgreSQL
BOOLEAN       -- TRUE, FALSE, NULL
-- MySQL
BOOL, BOOLEAN -- Synonym for TINYINT(1)
```

### **Corner Cases & Tricky Questions**

#### **Question 1: Three-State Logic**
**Question:** "How do you handle unknown/undefined states?"

**Answer:** 
```sql
-- BIT can be NULL for three states:
-- 1 = True, 0 = False, NULL = Unknown
IsActive BIT NULL
```

**Follow-up:** "How to query for unknown states?"
```sql
SELECT * FROM Users WHERE IsActive IS NULL;
```

#### **Question 2: Storage Optimization**
**Question:** "How many BIT columns can you have in a table before they consume additional storage?"

**Answer:** 
- SQL Server: 1-8 BIT columns = 1 byte total
- 9-16 BIT columns = 2 bytes, etc.
- **Optimization:** Group BIT columns together

### **Common Patterns**

#### **Pattern 1: Status Flags**
```sql
CREATE TABLE Users (
    IsActive BIT DEFAULT 1,
    IsVerified BIT DEFAULT 0,
    IsLocked BIT DEFAULT 0
);
```

#### **Pattern 2: Feature Toggles**
```sql
CREATE TABLE Settings (
    AllowNotifications BIT DEFAULT 1,
    EmailAlerts BIT DEFAULT 0,
    DarkMode BIT DEFAULT 0
);
```

---

## 📄 **JSON/XML DATA TYPES**

### **Core Knowledge Base**

#### **JSON Support**
```sql
-- SQL Server 2016+
JSON_DATA NVARCHAR(MAX)   -- Store as text with validation
-- Or use JSON type in other databases

-- PostgreSQL
JSON       -- Store as text, validate on access
JSONB      -- Binary format, faster querying
```

### **Corner Cases & Tricky Questions**

#### **Question 1: JSON vs Relational**
**Question:** "When should you use JSON columns instead of relational tables?"

**Answer:**
- **Use JSON for:** Dynamic attributes, configuration, less queried data
- **Use relational for:** Frequently queried, structured data

**Example:**
```sql
-- Good for JSON: Product attributes that vary by category
ProductAttributes JSON  -- { "color": "red", "size": "XL", "material": "cotton" }

-- Bad for JSON: User addresses (should be relational table)
```

#### **Question 2: JSON Performance**
**Question:** "How do you index JSON data?"

**Answer:**
```sql
-- SQL Server: Computed column + index
ALTER TABLE Products 
ADD Color AS JSON_VALUE(Attributes, '$.color');

CREATE INDEX IX_Products_Color ON Products(Color);
```

### **Common Patterns**

#### **Pattern 1: Dynamic Attributes**
```sql
CREATE TABLE Products (
    Id INT PRIMARY KEY,
    FixedAttributes VARCHAR(100),
    DynamicAttributes JSON  -- Varies by product type
);
```

#### **Pattern 2: Audit Logging**
```sql
CREATE TABLE AuditLog (
    Id INT PRIMARY KEY,
    ActionDate DATETIME2,
    OldValues JSON,    -- Store entire old record
    NewValues JSON     -- Store entire new record
);
```

---

## 🎯 **INTERVIEW STRATEGY GUIDE**

### **How to Approach Data Type Questions**

#### **Step 1: Understand Requirements**
- Ask about data size and growth
- Consider internationalization needs
- Plan for future scalability

#### **Step 2: Consider Performance**
- Choose smallest sufficient type
- Consider indexing requirements
- Plan for storage optimization

#### **Step 3: Think About Maintenance**
- Choose standard, well-supported types
- Document unusual type choices
- Consider team familiarity

### **Red Flags Interviewers Watch For**

1. **Using wrong type for domain** (FLOAT for money)
2. **Over-engineering simple problems** (JSON for static data)
3. **Ignoring international requirements** (VARCHAR for non-English text)
4. **Not considering NULL handling**
5. **Poor performance choices** (wrong indexing strategy)

### **Impressive Responses**

**When asked "Why choose X type?" respond with:**
- "I chose DECIMAL for financial data because..."
- "I considered NVARCHAR for international support since..."
- "The storage implications of this choice are..."
- "This allows for future growth because..."

This comprehensive guide gives you both the technical depth and the strategic thinking that interviewers look for in senior .NET/SQL developers.
