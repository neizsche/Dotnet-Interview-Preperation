# Complete Guide to Basic SQL Operations

## ðŸ“š **COMPREHENSIVE KNOWLEDGE BASE**

### **1. SELECT Statement Fundamentals**

**Core Syntax:**
```sql
SELECT column1, column2, ...
FROM table_name;
```

**Key Concepts:**
- **Projection**: Selecting specific columns
- **Selection**: Filtering rows (using WHERE)
- **Execution Order**: FROM â†’ WHERE â†’ SELECT

**Common Patterns:**
```sql
-- Select all columns
SELECT * FROM employees;

-- Select specific columns
SELECT first_name, last_name, salary FROM employees;

-- Select with expressions
SELECT first_name, salary * 12 as annual_salary FROM employees;
```

### **2. WHERE Clause Deep Dive**

**Basic Syntax:**
```sql
SELECT columns FROM table WHERE condition;
```

**Operator Categories:**
- **Comparison**: =, <>, <, >, <=, >=
- **Logical**: AND, OR, NOT
- **Range**: BETWEEN, IN
- **Pattern**: LIKE
- **Null**: IS NULL, IS NOT NULL

## ðŸ” **CORNER CASES & TRICKY SCENARIOS**

### **1. NULL Value Handling**

**Tricky Scenario:**
```sql
-- This WON'T work as expected
SELECT * FROM employees WHERE salary = NULL;

-- Correct approach
SELECT * FROM employees WHERE salary IS NULL;
```

**Why it's tricky:** NULL represents unknown value, so `= NULL` always returns NULL (treated as false)

**Follow-up Question:** "Why can't we use = NULL for null comparisons?"

**Expected Answer:** NULL is not a value but represents missing/unknown data. Equality comparisons with NULL always return NULL, which is treated as false in WHERE clauses.

### **2. String Comparison Case Sensitivity**

**Tricky Scenario:**
```sql
-- Might return different results based on database collation
SELECT * FROM employees WHERE first_name = 'john';
```

**Corner Case:** Database collation affects string comparisons. Some databases are case-sensitive by default.

**Solution:**
```sql
-- Case-insensitive comparison
SELECT * FROM employees WHERE LOWER(first_name) = LOWER('john');
```

### **3. Date Comparisons**

**Tricky Scenario:**
```sql
-- This might not work if hire_date has time component
SELECT * FROM employees WHERE hire_date = '2023-01-01';
```

**Solution:**
```sql
-- Better approach for date-only comparison
SELECT * FROM employees WHERE hire_date >= '2023-01-01' 
                         AND hire_date < '2023-01-02';
```

## â“ **TRICKY INTERVIEW QUESTIONS & ANSWERS**

### **Question 1: "What's the difference between WHERE and HAVING?"**

**What they're testing:** Understanding of SQL execution order and aggregation.

**Expected Answer:**
"WHERE filters rows BEFORE aggregation, while HAVING filters groups AFTER aggregation. WHERE cannot use aggregate functions, but HAVING can."

**Example:**
```sql
-- WHERE: Filter employees before counting
SELECT department, COUNT(*) 
FROM employees 
WHERE salary > 50000          -- Filters individual rows
GROUP BY department;

-- HAVING: Filter departments after counting
SELECT department, COUNT(*) 
FROM employees 
GROUP BY department 
HAVING COUNT(*) > 10;         -- Filters grouped results
```

### **Question 2: "Why use column aliases and when can't you use them in WHERE?"**

**What they're testing:** Understanding of SQL execution order.

**Expected Answer:**
"Column aliases are defined in the SELECT phase, which executes AFTER the WHERE phase. Therefore, you can't reference aliases in WHERE clauses."

**Example:**
```sql
-- This WON'T work:
SELECT first_name, salary * 12 as annual_salary 
FROM employees 
WHERE annual_salary > 60000;  -- Error: alias not recognized

-- This WORKS:
SELECT first_name, salary * 12 as annual_salary 
FROM employees 
WHERE salary * 12 > 60000;    -- Use original expression
```

### **Question 3: "What's the difference between DISTINCT and GROUP BY with no aggregates?"**

**What they're testing:** Understanding of duplicate removal mechanisms.

**Expected Answer:**
"Both can remove duplicates, but DISTINCT is clearer for simple duplicate removal. GROUP BY is meant for aggregation, though it can remove duplicates when used without aggregate functions."

**Example:**
```sql
-- Both return unique departments
SELECT DISTINCT department FROM employees;

SELECT department FROM employees GROUP BY department;
```

**Performance Note:** They might be similar, but it depends on the database optimizer.

## ðŸŽ¯ **COMMON PATTERNS & APPROACHES**

### **Pattern 1: Conditional Selection with CASE in SELECT**

**Use Case:** Display different values based on conditions without filtering rows.

```sql
SELECT 
    first_name,
    salary,
    CASE 
        WHEN salary > 100000 THEN 'High'
        WHEN salary > 50000 THEN 'Medium'
        ELSE 'Low'
    END as salary_grade
FROM employees;
```

**Interview Question:** "When would you use CASE in SELECT vs WHERE?"

**Answer:** "CASE in SELECT transforms output values, while WHERE filters rows. Use CASE when you want to categorize data for display, and WHERE when you want to exclude rows entirely."

### **Pattern 2: Combining Multiple Conditions**

**Complex WHERE clauses require careful logic:**

```sql
-- Correct grouping of OR conditions
SELECT * FROM employees 
WHERE (department = 'IT' OR department = 'HR')
  AND salary > 50000;

-- Common mistake: missing parentheses
SELECT * FROM employees 
WHERE department = 'IT' OR department = 'HR' AND salary > 50000;
-- This evaluates as: department = 'IT' OR (department = 'HR' AND salary > 50000)
```

### **Pattern 3: LIMIT/TOP for Sampling and Pagination**

**Different database syntax:**
```sql
-- MySQL/PostgreSQL
SELECT * FROM employees ORDER BY salary DESC LIMIT 10;

-- SQL Server
SELECT TOP 10 * FROM employees ORDER BY salary DESC;

-- Oracle
SELECT * FROM employees ORDER BY salary DESC 
WHERE ROWNUM <= 10;
```

**Interview Question:** "How would you implement pagination with LIMIT?"

**Answer:** "Use LIMIT with OFFSET: `LIMIT 10 OFFSET 20` for page 3 (skip 20, take 10). But for large datasets, seek method with WHERE clause is more efficient."

## ðŸ”„ **FOLLOW-UP QUESTIONS TO EXPECT**

### **Follow-up 1: "What's the execution order of a SQL query?"**

**Expected Answer:**
"FROM â†’ WHERE â†’ GROUP BY â†’ HAVING â†’ SELECT â†’ ORDER BY â†’ LIMIT"

**Why this matters:** Understanding this explains why you can't use aliases in WHERE but can in ORDER BY.

### **Follow-up 2: "How does NULL affect arithmetic operations?"**

**Expected Answer:**
"Any arithmetic operation with NULL returns NULL. For example: `10 + NULL = NULL`, `NULL * 5 = NULL`"

**Example:**
```sql
SELECT salary, bonus, salary + bonus as total 
FROM employees;
-- If bonus is NULL, total will be NULL
```

### **Follow-up 3: "What's the difference between != and <>?"**

**Expected Answer:**
"They are functionally equivalent - both mean 'not equal'. It's a matter of personal/coding standard preference."

## ðŸš¨ **PERFORMANCE CONSIDERATIONS**

### **1. SELECT * vs Specific Columns**

**Bad Practice:**
```sql
SELECT * FROM employees;  -- Returns all columns
```

**Better Practice:**
```sql
SELECT first_name, last_name, department FROM employees;
```

**Why:** Reduces network traffic and memory usage. Also safer if table schema changes.

### **2. WHERE Clause Optimization**

**Inefficient:**
```sql
SELECT * FROM employees WHERE YEAR(hire_date) = 2023;
```

**Efficient:**
```sql
SELECT * FROM employees 
WHERE hire_date >= '2023-01-01' AND hire_date < '2024-01-01';
```

**Why:** The first prevents index usage due to function on column.

## ðŸ’¡ **ADVANCED CORNER CASES**

### **1. Boolean Algebra in WHERE Clauses**

**Tricky Scenario:**
```sql
-- What happens with multiple NOT conditions?
SELECT * FROM employees 
WHERE NOT (department = 'IT' AND salary > 50000);

-- Equivalent to:
SELECT * FROM employees 
WHERE department <> 'IT' OR salary <= 50000;
```

**Interview Question:** "How would you rewrite a complex NOT condition using De Morgan's laws?"

### **2. Three-Valued Logic with NULL**

**Understanding TRUE/FALSE/UNKNOWN:**
```sql
-- These all return UNKNOWN (treated as FALSE):
WHERE NULL = NULL
WHERE NULL = 5
WHERE NULL <> 5

-- These return TRUE:
WHERE NULL IS NULL
WHERE 5 IS NOT NULL
```

## ðŸ§ª **PRACTICE EXERCISES**

### **Exercise 1: Fix the Query**
```sql
-- Original (has issues):
SELECT first_name, salary * 1.1 as new_salary
FROM employees
WHERE new_salary > 60000
ORDER BY department;

-- Fixed version:
SELECT first_name, salary * 1.1 as new_salary
FROM employees
WHERE salary * 1.1 > 60000
ORDER BY department;
```

### **Exercise 2: Complex Conditions**
"Write a query to find employees in IT or HR departments, with salary between 50k and 100k, but exclude anyone hired before 2020."

**Solution:**
```sql
SELECT first_name, last_name, department, salary, hire_date
FROM employees
WHERE (department = 'IT' OR department = 'HR')
  AND salary BETWEEN 50000 AND 100000
  AND hire_date >= '2020-01-01';
```

## ðŸ“Š **INTERVIEW PREPARATION CHECKLIST**

- [ ] Can explain SQL execution order confidently
- [ ] Understand NULL handling in all operations
- [ ] Know when to use WHERE vs HAVING
- [ ] Can handle complex logical conditions
- [ ] Understand performance implications of different approaches
- [ ] Can explain why aliases can't be used in WHERE
- [ ] Know different database syntax variations (LIMIT vs TOP)
- [ ] Understand case sensitivity in string comparisons
- [ ] Can handle date comparisons properly
- [ ] Know when to use SELECT * vs specific columns

This comprehensive guide covers everything you need to demonstrate deep understanding of basic SQL operations in your interview. The key is not just knowing the syntax, but understanding the underlying concepts and reasoning behind each feature.
