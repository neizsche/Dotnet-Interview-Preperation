# Complete Guide to SQL Filtering and Sorting

## ðŸ“š **COMPREHENSIVE KNOWLEDGE BASE**

### **1. Comparison Operators Deep Dive**

#### **Basic Syntax:**
```sql
SELECT * FROM employees WHERE salary = 50000;
SELECT * FROM products WHERE price <> 100;
SELECT * FROM orders WHERE order_date < '2023-01-01';
```

#### **Key Concepts:**
- **Type Compatibility**: Both sides must be comparable data types
- **NULL Handling**: `NULL = NULL` returns `NULL` (not TRUE)
- **Implicit Conversion**: Database may convert types automatically (can cause performance issues)

#### **Corner Cases:**
```sql
-- These may behave unexpectedly:
WHERE column = NULL;  -- WRONG! Always returns NULL (false)
WHERE column = '100'; -- String vs Number comparison
WHERE date_column = '2023-01-01'; -- Depends on date format settings
```

### **2. Logical Operators (AND, OR, NOT)**

#### **Operator Precedence:**
```sql
-- NOT > AND > OR
WHERE NOT status = 'active' AND department = 'IT' OR salary > 50000;
-- Equivalent to: ((NOT (status = 'active')) AND (department = 'IT')) OR (salary > 50000)
```

#### **Common Patterns:**
```sql
-- Multiple conditions
WHERE department = 'Sales' AND salary > 50000 AND hire_date > '2020-01-01';

-- OR for alternative conditions
WHERE department = 'IT' OR department = 'Engineering';

-- Combining AND/OR with parentheses
WHERE (department = 'Sales' AND salary > 50000) 
   OR (department = 'IT' AND salary > 70000);
```

### **3. BETWEEN Operator**

#### **Syntax and Inclusion:**
```sql
-- INCLUSIVE of boundaries
WHERE salary BETWEEN 30000 AND 50000;  -- 30000 and 50000 INCLUDED
-- Equivalent to: salary >= 30000 AND salary <= 50000
```

#### **Date Ranges:**
```sql
-- Date ranges (careful with time components!)
WHERE order_date BETWEEN '2023-01-01' AND '2023-01-31';
-- Includes all times on Jan 31st

-- Better approach for dates only:
WHERE order_date >= '2023-01-01' AND order_date < '2023-02-01';
```

### **4. IN Operator**

#### **Basic Usage:**
```sql
WHERE department IN ('IT', 'Sales', 'Marketing');
-- Equivalent to: department = 'IT' OR department = 'Sales' OR department = 'Marketing'
```

#### **Performance Considerations:**
```sql
-- Good for small lists
WHERE id IN (1, 2, 3, 4, 5);

-- Problematic for large lists
WHERE id IN (SELECT id FROM large_table WHERE condition);  -- May be slow

-- Consider JOIN for large IN lists
SELECT t1.* FROM table1 t1 
JOIN (SELECT id FROM large_table WHERE condition) t2 
ON t1.id = t2.id;
```

### **5. LIKE Operator with Wildcards**

#### **Wildcard Types:**
- `%` - Matches zero or more characters
- `_` - Matches exactly one character

#### **Pattern Examples:**
```sql
WHERE name LIKE 'John%';     -- Starts with John
WHERE name LIKE '%Smith';    -- Ends with Smith  
WHERE name LIKE '%John%';    -- Contains John anywhere
WHERE name LIKE 'J_n';       -- J followed by any character, then n
WHERE name LIKE 'J__n';      -- J, two characters, then n
WHERE name LIKE 'J\%';       -- Escape: literally starts with J%
```

#### **Performance Warning:**
```sql
-- These can't use indexes effectively:
WHERE name LIKE '%Smith';    -- Leading wildcard = full table scan
WHERE name LIKE '%John%';    -- Wildcards on both sides

-- These CAN use indexes:
WHERE name LIKE 'Smith%';    -- Trailing wildcard only
```

### **6. IS NULL / IS NOT NULL**

#### **NULL Handling:**
```sql
-- Correct ways to check for NULL
WHERE column_name IS NULL;
WHERE column_name IS NOT NULL;

-- Common mistakes
WHERE column_name = NULL;    -- WRONG! Always returns NULL (false)
WHERE column_name <> NULL;   -- WRONG! Always returns NULL (false)
```

#### **NULL in Expressions:**
```sql
-- NULL propagates through expressions
SELECT 5 + NULL;        -- Returns NULL
SELECT NULL = NULL;     -- Returns NULL (not TRUE)
SELECT NULL OR TRUE;    -- Returns TRUE (NULL treated as unknown)
```

### **7. CASE Statements**

#### **Basic Syntax:**
```sql
-- Simple CASE
SELECT 
    name,
    CASE department 
        WHEN 'IT' THEN 'Technology'
        WHEN 'Sales' THEN 'Business'
        ELSE 'Other'
    END as department_group
FROM employees;

-- Searched CASE (more flexible)
SELECT 
    name,
    salary,
    CASE 
        WHEN salary < 30000 THEN 'Low'
        WHEN salary BETWEEN 30000 AND 70000 THEN 'Medium'  
        WHEN salary > 70000 THEN 'High'
        ELSE 'Unknown'
    END as salary_band
FROM employees;
```

#### **Advanced Usage:**
```sql
-- In WHERE clause
WHERE 
    CASE 
        WHEN department = 'IT' THEN salary > 70000
        WHEN department = 'Sales' THEN salary > 50000
        ELSE salary > 30000
    END;

-- In aggregation
SELECT 
    department,
    COUNT(CASE WHEN salary > 50000 THEN 1 END) as high_earners,
    AVG(CASE WHEN gender = 'F' THEN salary END) as avg_female_salary
FROM employees
GROUP BY department;
```

## ðŸŽ¯ **TRICKY QUESTIONS & CORNER CASES**

### **Question 1: NULL Handling**
**Question:** "Why does `WHERE column = NULL` not work as expected?"

**What Interviewer Seeks:**
- Understanding of three-valued logic (TRUE, FALSE, UNKNOWN)
- Knowledge of proper NULL handling

**Answer:**
```sql
-- NULL represents unknown value, so:
NULL = NULL  -- Returns UNKNOWN (treated as FALSE in WHERE)
NULL = 5     -- Returns UNKNOWN (treated as FALSE)

-- Correct approach:
WHERE column IS NULL;     -- Check for NULL
WHERE column IS NOT NULL; -- Check for non-NULL
WHERE column = 5 OR column IS NULL; -- Include NULLs in equality check
```

### **Question 2: BETWEEN with Dates**
**Question:** "What's wrong with using BETWEEN for date ranges?"

**What Interviewer Seeks:**
- Understanding of time components in dates
- Knowledge of inclusive/exclusive range boundaries

**Answer:**
```sql
-- Problem: Includes entire end date (time component matters)
WHERE order_date BETWEEN '2023-01-01' AND '2023-01-31';
-- Includes '2023-01-31 23:59:59.999'

-- Better approach (exclusive end):
WHERE order_date >= '2023-01-01' AND order_date < '2023-02-01';
-- Includes all of January, excludes February
```

### **Question 3: LIKE Performance**
**Question:** "When would a LIKE query be slow and how would you optimize it?"

**What Interviewer Seeks:**
- Understanding of index usage
- Knowledge of full-text search alternatives

**Answer:**
```sql
-- Slow (leading wildcard prevents index usage):
WHERE name LIKE '%Smith%';

-- Fast (index can be used):
WHERE name LIKE 'Smith%';

-- Optimization strategies:
-- 1. Use full-text search for complex pattern matching
-- 2. Consider reverse indexing for suffix searches
-- 3. Use dedicated search engines (Elasticsearch) for large datasets
```

### **Question 4: IN vs EXISTS**
**Question:** "When should you use EXISTS instead of IN with subqueries?"

**What Interviewer Seeks:**
- Understanding of query execution
- Performance optimization knowledge

**Answer:**
```sql
-- IN (may materialize entire subquery result):
SELECT * FROM employees 
WHERE department_id IN (SELECT id FROM departments WHERE active = 1);

-- EXISTS (stops at first match, often faster):
SELECT * FROM employees e
WHERE EXISTS (SELECT 1 FROM departments d 
              WHERE d.id = e.department_id AND d.active = 1);

-- Use EXISTS when:
-- 1. Subquery returns many rows
-- 2. You're checking for existence rather than specific values
-- 3. Correlated subqueries are involved
```

## ðŸ”„ **COMMON PATTERNS & APPROACHES**

### **Pattern 1: Dynamic Filtering**
**Scenario:** Build queries with optional filters

**Approach:**
```sql
-- Using COALESCE for optional parameters
WHERE (name = @search_name OR @search_name IS NULL)
  AND (salary >= @min_salary OR @min_salary IS NULL)
  AND (department = @dept OR @dept IS NULL);

-- Using CASE in WHERE (advanced)
WHERE 
    CASE 
        WHEN @filter_type = 'name' THEN name LIKE @pattern
        WHEN @filter_type = 'salary' THEN salary > @amount
        ELSE 1=1  -- Return all rows if no filter specified
    END;
```

### **Pattern 2: Priority-based Filtering**
**Scenario:** Find records matching multiple criteria with priority

**Approach:**
```sql
-- Using CASE in ORDER BY for priority
SELECT * FROM products 
WHERE name LIKE '%laptop%' OR category = 'electronics'
ORDER BY 
    CASE 
        WHEN name LIKE '%laptop%' AND category = 'electronics' THEN 1
        WHEN name LIKE '%laptop%' THEN 2  
        WHEN category = 'electronics' THEN 3
        ELSE 4
    END;
```

### **Pattern 3: Exclusion Patterns**
**Scenario:** Find records that don't match certain criteria

**Approach:**
```sql
-- Using NOT with complex conditions
WHERE NOT (status = 'inactive' AND last_login < '2022-01-01');

-- Using EXISTS for exclusion
SELECT * FROM customers c
WHERE NOT EXISTS (
    SELECT 1 FROM orders o 
    WHERE o.customer_id = c.id AND o.status = 'cancelled'
);
```

### **Pattern 4: Range-based Categorization**
**Scenario:** Categorize numeric values into bands

**Approach:**
```sql
-- Using CASE for categorization
SELECT 
    customer_id,
    total_purchases,
    CASE 
        WHEN total_purchases >= 1000 THEN 'Gold'
        WHEN total_purchases >= 500 THEN 'Silver' 
        WHEN total_purchases >= 100 THEN 'Bronze'
        ELSE 'Standard'
    END as customer_tier
FROM customer_stats;
```

## ðŸ§ª **FOLLOW-UP QUESTIONS TO TEST DEPTH**

### **Follow-up 1: Three-Valued Logic**
**Question:** "What happens when you combine NULL with AND/OR operators?"

**Expected Answer:**
```sql
-- Truth table for NULL combinations:
TRUE AND NULL = NULL    (UNKNOWN)
FALSE AND NULL = FALSE  
TRUE OR NULL = TRUE     
FALSE OR NULL = NULL    (UNKNOWN)

-- Practical example:
WHERE salary > 50000 OR department IS NULL;
-- Returns rows where salary > 50000 OR department is NULL
```

### **Follow-up 2: Performance Implications**
**Question:** "How would you rewrite this query to make better use of indexes?"

**Example Query:**
```sql
-- Original (problematic):
WHERE YEAR(order_date) = 2023 AND MONTH(order_date) = 1;

-- Optimized version:
WHERE order_date >= '2023-01-01' AND order_date < '2023-02-01';
```

### **Follow-up 3: Edge Cases**
**Question:** "What edge cases should you consider when using string comparison with LIKE?"

**Expected Considerations:**
- Case sensitivity (depends on collation)
- Wildcard escaping
- Performance with leading wildcards
- Empty string vs NULL handling
- Unicode and special characters

### **Follow-up 4: Set Operations**
**Question:** "When would you use NOT IN vs NOT EXISTS?"

**Key Differences:**
```sql
-- NOT IN (beware of NULLs in subquery):
WHERE id NOT IN (1, 2, 3, NULL);  -- Always returns empty set!

-- NOT EXISTS (NULL-safe):
WHERE NOT EXISTS (SELECT 1 FROM table WHERE condition);
```

## ðŸ’¡ **PRO-TIPS FOR INTERVIEWS**

### **1. Always Consider NULLs**
```sql
-- Bad: May exclude NULL values unintentionally
WHERE column <> 'value';

-- Good: Explicit NULL handling  
WHERE column <> 'value' OR column IS NULL;
```

### **2. Use Parentheses Liberally**
```sql
-- Clear intent with parentheses
WHERE (condition1 AND condition2) OR (condition3 AND condition4);
```

### **3. Think About Performance**
- Avoid functions on indexed columns in WHERE clauses
- Use leading wildcards in LIKE sparingly
- Consider query execution order

### **4. Test Edge Cases**
- Empty strings vs NULL
- Boundary values in BETWEEN
- Case sensitivity in string comparisons
- Time components in date comparisons

This comprehensive guide covers everything you need to master SQL filtering and sorting for your .NET interview. Practice these concepts with real queries to build muscle memory!
