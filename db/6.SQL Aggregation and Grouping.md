# Complete Guide to SQL Aggregation and Grouping

## ðŸ“š **KNOWLEDGE BASE - AGGREGATION FUNDAMENTALS**

### **Aggregate Functions Deep Dive**

#### **COUNT() Function**
```sql
-- Basic COUNT
SELECT COUNT(*) FROM employees; -- Counts all rows including NULLs
SELECT COUNT(1) FROM employees; -- Same as COUNT(*)
SELECT COUNT(column_name) FROM employees; -- Counts non-NULL values only
SELECT COUNT(DISTINCT department) FROM employees; -- Counts unique departments
```

**Key Points:**
- `COUNT(*)` counts all rows, including those with NULL values
- `COUNT(column_name)` counts only non-NULL values in that column
- `COUNT(DISTINCT column)` counts distinct non-NULL values
- Performance: `COUNT(*)` is generally fastest

#### **SUM() and AVG() Functions**
```sql
SELECT 
    SUM(salary) AS total_salary,
    AVG(salary) AS average_salary,
    SUM(DISTINCT salary) AS unique_salaries_sum,
    AVG(DISTINCT salary) AS unique_salaries_avg
FROM employees;
```

**Important Behaviors:**
- `SUM()` and `AVG()` ignore NULL values
- `SUM()` of no rows returns NULL, not 0
- Use `COALESCE(SUM(column), 0)` to handle NULL results
- `AVG()` = `SUM() / COUNT(non-null values)`

#### **MIN() and MAX() Functions**
```sql
SELECT 
    MIN(hire_date) AS first_hire,
    MAX(hire_date) AS latest_hire,
    MIN(salary) AS lowest_salary,
    MAX(salary) AS highest_salary
FROM employees;
```

**Key Insights:**
- Work with various data types (dates, numbers, strings)
- NULL values are ignored
- On strings: MIN = alphabetically first, MAX = alphabetically last

#### **STRING_AGG() / GROUP_CONCAT()**
```sql
-- SQL Server
SELECT 
    department,
    STRING_AGG(employee_name, ', ') WITHIN GROUP (ORDER BY employee_name) AS employees
FROM employees
GROUP BY department;

-- MySQL
SELECT 
    department,
    GROUP_CONCAT(employee_name ORDER BY employee_name SEPARATOR ', ') AS employees
FROM employees
GROUP BY department;
```

### **GROUP BY Deep Dive**

#### **Basic GROUP BY**
```sql
SELECT department, COUNT(*) AS employee_count
FROM employees
GROUP BY department;
```

**Rules:**
1. All non-aggregated columns in SELECT must be in GROUP BY
2. You can group by expressions: `GROUP BY YEAR(hire_date)`
3. You can group by multiple columns

#### **GROUP BY with Multiple Columns**
```sql
SELECT 
    department,
    YEAR(hire_date) AS hire_year,
    COUNT(*) AS employee_count,
    AVG(salary) AS avg_salary
FROM employees
WHERE salary > 50000  -- Filter before grouping
GROUP BY department, YEAR(hire_date)
HAVING COUNT(*) > 5   -- Filter after grouping
ORDER BY department, hire_year;
```

### **HAVING vs WHERE**
```sql
-- WHERE filters rows BEFORE grouping
-- HAVING filters groups AFTER grouping

SELECT department, AVG(salary) AS avg_salary
FROM employees
WHERE hire_date > '2020-01-01'  -- Individual row filter
GROUP BY department
HAVING AVG(salary) > 75000      -- Group filter
   AND COUNT(*) > 3;            -- Another group filter
```

## âš ï¸ **CORNER CASES & GOTCHAS**

### **1. NULL Handling in Aggregates**
```sql
-- Sample data: salaries = [1000, 2000, NULL, 3000]
SELECT 
    COUNT(*) AS count_all,          -- 4
    COUNT(salary) AS count_salary,  -- 3 (NULL excluded)
    SUM(salary) AS total_salary,    -- 6000 (NULL excluded)
    AVG(salary) AS avg_salary       -- 2000 (6000/3)
FROM employees;
```

### **2. Empty Group Results**
```sql
-- When no rows match WHERE condition:
SELECT department, AVG(salary) 
FROM employees 
WHERE salary > 1000000  -- No employees have this salary
GROUP BY department;
-- Returns: No rows (not NULL values)
```

### **3. GROUP BY with NULL Values**
```sql
-- NULLs form their own group
SELECT department, COUNT(*)
FROM employees
GROUP BY department;
-- If some employees have NULL department, they'll be grouped together
```

### **4. HAVING with Complex Conditions**
```sql
-- Can use multiple aggregate functions in HAVING
SELECT department, 
       AVG(salary) AS avg_sal,
       MAX(salary) AS max_sal
FROM employees
GROUP BY department
HAVING AVG(salary) > 50000 
   AND MAX(salary) < 200000
   AND COUNT(*) BETWEEN 5 AND 20;
```

## ðŸ” **TRICKY INTERVIEW QUESTIONS & ANSWERS**

### **Question 1: The COUNT(*) vs COUNT(column) Trap**
**Question:** "What's the difference between `COUNT(*)` and `COUNT(employee_id)`? When would you use each?"

**What Interviewer Seeks:** Understanding of NULL handling and performance implications.

**Answer:** 
"`COUNT(*)` counts all rows regardless of NULLs, while `COUNT(column)` counts only non-NULL values in that specific column. I'd use `COUNT(*)` when I need the total number of rows, and `COUNT(column)` when I want to count only rows with valid data in that column. Performance-wise, `COUNT(*)` is usually optimized better by database engines."

### **Question 2: The HAVING vs WHERE Confusion**
**Question:** "Can you use WHERE instead of HAVING to filter on aggregate functions?"

**What Interviewer Seeks:** Understanding of SQL execution order.

**Answer:** 
"No, because of SQL's logical processing order. WHERE clause executes before grouping happens, so aggregate functions aren't available yet. HAVING executes after grouping, so it can filter based on aggregate results. The order is: FROM â†’ WHERE â†’ GROUP BY â†’ HAVING â†’ SELECT â†’ ORDER BY."

### **Question 3: The GROUP BY Multiple Columns Scenario**
**Question:** "What does this query return and why?"
```sql
SELECT department, job_title, COUNT(*)
FROM employees
GROUP BY department, job_title;
```

**What Interviewer Seeks:** Understanding of multi-column grouping.

**Answer:** 
"This returns the count of employees for each unique combination of department and job title. For example, if we have 'Engineering' department with 'Manager' and 'Developer' titles, we'll get two rows: one counting managers in engineering, another counting developers in engineering."

### **Question 4: The AVG() with NULL Values**
**Question:** "If I have salaries [1000, NULL, 2000, NULL], what will AVG(salary) return?"

**What Interviewer Seeks:** NULL handling knowledge.

**Answer:** 
"AVG(salary) will return 1500, because it sums the non-NULL values (1000 + 2000 = 3000) and divides by the count of non-NULL values (2), so 3000/2 = 1500. NULL values are completely ignored in the calculation."

## ðŸŽ¯ **COMMON PATTERNS & APPROACHES**

### **Pattern 1: Percentage of Total**
```sql
-- Calculate each department's salary as percentage of total
SELECT 
    department,
    SUM(salary) AS dept_salary,
    ROUND(SUM(salary) * 100.0 / (SELECT SUM(salary) FROM employees), 2) AS pct_of_total
FROM employees
GROUP BY department
HAVING SUM(salary) > 0;
```

**Approach:** Use subquery in SELECT to get total, then calculate percentage.

### **Pattern 2: Ranking Within Groups**
```sql
-- Find top 3 highest paid employees in each department
WITH RankedEmployees AS (
    SELECT 
        department,
        employee_name,
        salary,
        DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) as rank_in_dept
    FROM employees
)
SELECT department, employee_name, salary
FROM RankedEmployees
WHERE rank_in_dept <= 3;
```

**Approach:** Use window functions with PARTITION BY for group-wise ranking.

### **Pattern 3: Comparing with Group Average**
```sql
-- Find employees earning more than their department average
SELECT 
    e.employee_name,
    e.department,
    e.salary,
    dept_avg.avg_salary
FROM employees e
INNER JOIN (
    SELECT department, AVG(salary) as avg_salary
    FROM employees
    GROUP BY department
) dept_avg ON e.department = dept_avg.department
WHERE e.salary > dept_avg.avg_salary;
```

**Approach:** Create department averages subquery and JOIN back to main table.

### **Pattern 4: Rolling Calculations**
```sql
-- 3-month moving average of sales
SELECT 
    month,
    sales,
    AVG(sales) OVER (ORDER BY month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as moving_avg_3mo
FROM monthly_sales;
```

**Approach:** Use window functions with frame clauses for rolling calculations.

### **Pattern 5: Finding Duplicates**
```sql
-- Find duplicate email addresses
SELECT email, COUNT(*) as duplicate_count
FROM users
GROUP BY email
HAVING COUNT(*) > 1;
```

**Approach:** GROUP BY the column(s) that should be unique, HAVING COUNT > 1.

## ðŸš€ **ADVANCED AGGREGATION PATTERNS**

### **ROLLUP - Hierarchical Summary**
```sql
-- Creates subtotals and grand total
SELECT 
    department,
    job_title,
    SUM(salary) AS total_salary
FROM employees
GROUP BY ROLLUP(department, job_title);
```
**Result:**
- Rows for each (department, job_title) combination
- Subtotal rows for each department (job_title = NULL)
- Grand total row (both department and job_title = NULL)

### **CUBE - All Combinations**
```sql
-- Creates all possible grouping combinations
SELECT 
    department,
    job_title,
    YEAR(hire_date) AS hire_year,
    COUNT(*) AS employee_count
FROM employees
GROUP BY CUBE(department, job_title, YEAR(hire_date));
```

### **GROUPING SETS - Specific Groupings**
```sql
-- Custom grouping combinations only
SELECT 
    department,
    job_title,
    COUNT(*) AS employee_count
FROM employees
GROUP BY GROUPING SETS (
    (department),                    -- Group by department only
    (job_title),                     -- Group by job_title only  
    (department, job_title),         -- Group by both
    ()                               -- Grand total
);
```

### **Filtered Aggregates (SQL Server)**
```sql
-- Conditional aggregation without CASE statements
SELECT 
    department,
    COUNT(*) AS total_employees,
    COUNT(*) FILTER (WHERE salary > 100000) AS high_earners,
    AVG(salary) FILTER (WHERE hire_date > '2020-01-01') AS new_hire_avg_salary
FROM employees
GROUP BY department;
```

## ðŸ’¡ **INTERVIEW FOLLOW-UP QUESTIONS TO EXPECT**

### **Depth Testing Questions:**
1. "How would you handle a scenario where you need to aggregate data from multiple related tables?"
2. "What performance considerations should you keep in mind with large datasets?"
3. "How would you debug a query that's returning unexpected aggregate results?"
4. "When would you prefer window functions over GROUP BY for analytical queries?"

### **Advanced Scenarios:**
5. "How do you calculate a cumulative running total without window functions?"
6. "What's the difference between ROLLUP and CUBE in terms of business use cases?"
7. "How would you implement a weighted average using SQL aggregates?"

## ðŸŽª **PRO-TIPS FOR INTERVIEW SUCCESS**

### **Always Mention:**
- "I need to consider NULL handling in my aggregates"
- "I should check if WHERE or HAVING is more appropriate for this filter"
- "For large datasets, I might need to consider indexing on GROUP BY columns"
- "I'll verify my results by checking edge cases like empty groups or NULL values"

### **Common Mistakes to Avoid:**
- Forgetting that COUNT(column) excludes NULLs
- Using HAVING for row-level filters (inefficient)
- Including non-aggregated columns in SELECT without GROUP BY
- Not considering the impact of NULLs on AVG() calculations

### **Demonstrate Depth By:**
- Discussing alternative approaches
- Considering performance implications
- Mentioning how you'd test your query
- Explaining the business context of the aggregation

This comprehensive guide covers everything you need to master aggregation and grouping for your interview. Practice writing these patterns until they become second nature!
