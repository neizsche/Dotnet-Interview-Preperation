# Authentication and Authorization Comprehensive Guide

## Table of Contents
1. [JWT and Bearer Authentication](#jwt-and-bearer-authentication)
2. [Cookie Authentication and Claims Transformation](#cookie-authentication-and-claims-transformation)
3. [Identity Framework and Custom Stores](#identity-framework-and-custom-stores)
4. [Role-based and Policy-based Authorization](#role-based-and-policy-based-authorization)
5. [External Providers](#external-providers)
6. [Comparison Tables](#comparison-tables)
7. [Interview Questions](#interview-questions)

---

## JWT and Bearer Authentication

### Deep Understanding

#### What is JWT?
JSON Web Tokens are an open standard (RFC 7519) that defines a compact, self-contained way for securely transmitting information between parties as a JSON object.

**JWT Structure:**
```
header.payload.signature
```

**Components:**
1. **Header**: Algorithm and token type
2. **Payload**: Claims (data) about the entity
3. **Signature**: Verification of token integrity

```json
// Header
{
  "alg": "HS256",
  "typ": "JWT"
}

// Payload
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 1516242622
}
```

#### JWT Signing Algorithms

**Symmetric Algorithms (Shared Secret):**
- HS256, HS384, HS512
- Same secret used for signing and verification

**Asymmetric Algorithms (Public/Private Key):**
- RS256, RS384, RS512
- Private key signs, public key verifies
- More secure for distributed systems

#### Bearer Authentication
Bearer tokens are a type of access token where the possessor of the token gets access to protected resources.

```http
Authorization: Bearer <token>
```

### Implementation Example

```csharp
// JWT Service Implementation
public class JwtService
{
    private readonly string _secretKey;
    private readonly string _issuer;
    private readonly string _audience;

    public JwtService(IConfiguration config)
    {
        _secretKey = config["Jwt:Secret"];
        _issuer = config["Jwt:Issuer"];
        _audience = config["Jwt:Audience"];
    }

    public string GenerateToken(User user, IList<string> roles)
    {
        var claims = new[]
        {
            new Claim(JwtRegisteredClaimNames.Sub, user.Id),
            new Claim(JwtRegisteredClaimNames.Email, user.Email),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
            new Claim(ClaimTypes.Name, user.UserName),
            new Claim("custom_claim", "custom_value")
        }.Concat(roles.Select(role => new Claim(ClaimTypes.Role, role)));

        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_secretKey));
        var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

        var token = new JwtSecurityToken(
            issuer: _issuer,
            audience: _audience,
            claims: claims,
            expires: DateTime.Now.AddHours(2),
            signingCredentials: creds);

        return new JwtSecurityTokenHandler().WriteToken(token);
    }

    public ClaimsPrincipal ValidateToken(string token)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_secretKey);

        var validationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(key),
            ValidateIssuer = true,
            ValidIssuer = _issuer,
            ValidateAudience = true,
            ValidAudience = _audience,
            ValidateLifetime = true,
            ClockSkew = TimeSpan.Zero // Strict expiration validation
        };

        try
        {
            var principal = tokenHandler.ValidateToken(token, validationParameters, out _);
            return principal;
        }
        catch (SecurityTokenException)
        {
            return null;
        }
    }
}
```

### Security Considerations

**Critical Security Aspects:**
1. **Secret Management**: Never hardcode secrets, use secure storage
2. **Token Expiration**: Always set reasonable expiration times
3. **Signature Verification**: Always validate token signatures
4. **Algorithm Validation**: Prevent algorithm substitution attacks
5. **Token Storage**: Secure storage in client applications

---

## Cookie Authentication and Claims Transformation

### Deep Understanding

#### Cookie Authentication Flow
1. User provides credentials
2. Server validates and creates authentication cookie
3. Cookie sent with subsequent requests
4. Server validates cookie and establishes identity

#### Claims Transformation
Process of modifying or adding claims during authentication:

```csharp
public class ClaimsTransformationService : IClaimsTransformation
{
    public async Task<ClaimsPrincipal> TransformAsync(ClaimsPrincipal principal)
    {
        var identity = principal.Identities.First();
        
        // Add custom claims based on existing claims
        if (identity.HasClaim(c => c.Type == ClaimTypes.Name))
        {
            var nameClaim = identity.FindFirst(ClaimTypes.Name);
            var transformedClaims = await GetAdditionalClaims(nameClaim.Value);
            
            identity.AddClaims(transformedClaims);
        }

        return principal;
    }
    
    private async Task<IEnumerable<Claim>> GetAdditionalClaims(string username)
    {
        // Fetch additional claims from database or external service
        return new[]
        {
            new Claim("custom_permission", "special_access"),
            new Claim("membership_level", "premium")
        };
    }
}
```

### Implementation Example

```csharp
// Cookie Authentication Configuration
services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
    .AddCookie(options =>
    {
        options.Cookie.Name = "AuthCookie";
        options.Cookie.HttpOnly = true;
        options.Cookie.SecurePolicy = CookieSecurePolicy.Always;
        options.Cookie.SameSite = SameSiteMode.Strict;
        options.ExpireTimeSpan = TimeSpan.FromHours(2);
        options.SlidingExpiration = true;
        options.LoginPath = "/Account/Login";
        options.AccessDeniedPath = "/Account/AccessDenied";
        options.Events = new CookieAuthenticationEvents
        {
            OnValidatePrincipal = async context =>
            {
                // Custom validation logic
                var userId = context.Principal.FindFirstValue(ClaimTypes.NameIdentifier);
                if (!await IsUserActive(userId))
                {
                    context.RejectPrincipal();
                    await context.HttpContext.SignOutAsync();
                }
            }
        };
    });

// Claims Transformation Registration
services.AddTransient<IClaimsTransformation, ClaimsTransformationService>();
```

---

## Identity Framework and Custom Stores

### Deep Understanding

#### ASP.NET Core Identity Architecture
```
User → IdentityManager → UserStore → Database
```

**Key Components:**
- `UserManager<TUser>`: User management operations
- `SignInManager<TUser>`: Authentication operations
- `RoleManager<TRole>`: Role management
- `IUserStore<TUser>`: Data persistence abstraction

### Custom Store Implementation

```csharp
// Custom User Store
public class CustomUserStore : IUserStore<ApplicationUser>, 
                              IUserPasswordStore<ApplicationUser>,
                              IUserEmailStore<ApplicationUser>
{
    private readonly CustomDbContext _context;

    public CustomUserStore(CustomDbContext context)
    {
        _context = context;
    }

    public async Task<IdentityResult> CreateAsync(ApplicationUser user, 
        CancellationToken cancellationToken = default)
    {
        user.Id = Guid.NewGuid().ToString();
        _context.Users.Add(user);
        await _context.SaveChangesAsync(cancellationToken);
        return IdentityResult.Success;
    }

    public async Task<ApplicationUser> FindByEmailAsync(string normalizedEmail, 
        CancellationToken cancellationToken = default)
    {
        return await _context.Users
            .FirstOrDefaultAsync(u => u.NormalizedEmail == normalizedEmail, cancellationToken);
    }

    // Implement other required methods...
    public Task SetPasswordHashAsync(ApplicationUser user, string passwordHash, 
        CancellationToken cancellationToken = default)
    {
        user.PasswordHash = passwordHash;
        return Task.CompletedTask;
    }

    public Task<string> GetPasswordHashAsync(ApplicationUser user, 
        CancellationToken cancellationToken = default)
    {
        return Task.FromResult(user.PasswordHash);
    }

    public Task<bool> HasPasswordAsync(ApplicationUser user, 
        CancellationToken cancellationToken = default)
    {
        return Task.FromResult(!string.IsNullOrEmpty(user.PasswordHash));
    }

    // Dispose and other methods...
    public void Dispose()
    {
        _context?.Dispose();
    }
}

// Custom Role Store
public class CustomRoleStore : IRoleStore<ApplicationRole>
{
    private readonly CustomDbContext _context;

    public CustomRoleStore(CustomDbContext context)
    {
        _context = context;
    }

    public async Task<IdentityResult> CreateAsync(ApplicationRole role, 
        CancellationToken cancellationToken = default)
    {
        role.Id = Guid.NewGuid().ToString();
        _context.Roles.Add(role);
        await _context.SaveChangesAsync(cancellationToken);
        return IdentityResult.Success;
    }

    public async Task<ApplicationRole> FindByNameAsync(string normalizedRoleName, 
        CancellationToken cancellationToken = default)
    {
        return await _context.Roles
            .FirstOrDefaultAsync(r => r.NormalizedName == normalizedRoleName, cancellationToken);
    }

    // Implement other required methods...
}
```

### Configuration

```csharp
services.AddIdentity<ApplicationUser, ApplicationRole>(options =>
{
    // Password settings
    options.Password.RequireDigit = true;
    options.Password.RequiredLength = 8;
    options.Password.RequireNonAlphanumeric = false;
    options.Password.RequireUppercase = true;
    options.Password.RequireLowercase = true;
    
    // Lockout settings
    options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(30);
    options.Lockout.MaxFailedAccessAttempts = 5;
    
    // User settings
    options.User.RequireUniqueEmail = true;
    options.SignIn.RequireConfirmedEmail = true;
})
.AddUserStore<CustomUserStore>()
.AddRoleStore<CustomRoleStore>()
.AddDefaultTokenProviders();
```

---

## Role-based and Policy-based Authorization

### Deep Understanding

#### Role-based Authorization
Simple permission model based on user roles:

```csharp
[Authorize(Roles = "Admin,Manager")]
public class AdminController : Controller
{
    [Authorize(Roles = "Admin")]
    public IActionResult SuperAdminAction()
    {
        return View();
    }
    
    [Authorize(Roles = "Manager")]
    public IActionResult ManagerAction()
    {
        return View();
    }
}
```

#### Policy-based Authorization
More flexible approach using requirements and handlers:

```csharp
// Custom Requirement
public class MinimumAgeRequirement : IAuthorizationRequirement
{
    public int MinimumAge { get; }

    public MinimumAgeRequirement(int minimumAge)
    {
        MinimumAge = minimumAge;
    }
}

// Requirement Handler
public class MinimumAgeHandler : AuthorizationHandler<MinimumAgeRequirement>
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context,
        MinimumAgeRequirement requirement)
    {
        var dateOfBirthClaim = context.User.FindFirst(c => c.Type == ClaimTypes.DateOfBirth);
        
        if (dateOfBirthClaim != null)
        {
            var dateOfBirth = Convert.ToDateTime(dateOfBirthClaim.Value);
            var age = DateTime.Today.Year - dateOfBirth.Year;
            
            if (age >= requirement.MinimumAge)
            {
                context.Succeed(requirement);
            }
        }

        return Task.CompletedTask;
    }
}

// Custom Policy with Multiple Requirements
public class ComplexRequirement : IAuthorizationRequirement
{
    public string RequiredDepartment { get; }

    public ComplexRequirement(string department)
    {
        RequiredDepartment = department;
    }
}

public class ComplexHandler : AuthorizationHandler<ComplexRequirement>
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context,
        ComplexRequirement requirement)
    {
        var departmentClaim = context.User.FindFirst("Department");
        var roleClaim = context.User.FindFirst(ClaimTypes.Role);

        if (departmentClaim?.Value == requirement.RequiredDepartment && 
            roleClaim?.Value == "Manager")
        {
            context.Succeed(requirement);
        }

        return Task.CompletedTask;
    }
}
```

### Policy Configuration

```csharp
services.AddAuthorization(options =>
{
    // Simple policy
    options.AddPolicy("Over18", policy => 
        policy.Requirements.Add(new MinimumAgeRequirement(18)));
    
    // Complex policy
    options.AddPolicy("FinanceManager", policy =>
    {
        policy.RequireRole("Manager");
        policy.RequireClaim("Department", "Finance");
        policy.Requirements.Add(new ComplexRequirement("Finance"));
    });
    
    // Custom policy with assertions
    options.AddPolicy("CustomPolicy", policy =>
        policy.RequireAssertion(context =>
        {
            var hasSpecialClaim = context.User.HasClaim("SpecialAccess", "true");
            var isInTimeWindow = DateTime.Now.Hour >= 9 && DateTime.Now.Hour <= 17;
            return hasSpecialClaim && isInTimeWindow;
        }));
});

// Register handlers
services.AddSingleton<IAuthorizationHandler, MinimumAgeHandler>();
services.AddSingleton<IAuthorizationHandler, ComplexHandler>();
```

### Resource-based Authorization

```csharp
public class DocumentAuthorizationHandler : 
    AuthorizationHandler<SameAuthorRequirement, Document>
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context,
        SameAuthorRequirement requirement, Document resource)
    {
        if (context.User.FindFirst(ClaimTypes.NameIdentifier)?.Value == resource.AuthorId)
        {
            context.Succeed(requirement);
        }

        return Task.CompletedTask;
    }
}

public class SameAuthorRequirement : IAuthorizationRequirement { }

// Usage in controller
[Authorize]
public class DocumentController : Controller
{
    private readonly IAuthorizationService _authorizationService;

    public DocumentController(IAuthorizationService authorizationService)
    {
        _authorizationService = authorizationService;
    }

    public async Task<IActionResult> Edit(int id)
    {
        var document = await _documentRepository.GetByIdAsync(id);
        
        var authResult = await _authorizationService.AuthorizeAsync(
            User, document, "SameAuthor");
        
        if (!authResult.Succeeded)
        {
            return Forbid();
        }

        return View(document);
    }
}
```

---

## External Providers (OAuth 2.0, OpenID Connect)

### Deep Understanding

#### OAuth 2.0 Flow
```
Client → Authorization Server → Resource Owner → Authorization Code → Access Token
```

#### OpenID Connect
Extension of OAuth 2.0 that adds identity layer (ID Token)

### Implementation Example

```csharp
services.AddAuthentication(options =>
{
    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = OpenIdConnectDefaults.AuthenticationScheme;
})
.AddCookie()
.AddOpenIdConnect("Google", options =>
{
    options.Authority = "https://accounts.google.com";
    options.ClientId = Configuration["Google:ClientId"];
    options.ClientSecret = Configuration["Google:ClientSecret"];
    options.CallbackPath = "/signin-google";
    options.SaveTokens = true;
    options.Scope.Add("profile");
    options.Scope.Add("email");
    
    options.Events = new OpenIdConnectEvents
    {
        OnTokenValidated = context =>
        {
            // Custom claims transformation
            var claims = new List<Claim>
            {
                new Claim("LoginProvider", "Google")
            };
            
            var identity = (ClaimsIdentity)context.Principal.Identity;
            identity.AddClaims(claims);
            
            return Task.CompletedTask;
        },
        OnRedirectToIdentityProvider = context =>
        {
            // Add custom parameters to authorization request
            context.ProtocolMessage.SetParameter("hd", "mycompany.com");
            return Task.CompletedTask;
        }
    };
})
.AddOAuth("GitHub", options =>
{
    options.ClientId = Configuration["GitHub:ClientId"];
    options.ClientSecret = Configuration["GitHub:ClientSecret"];
    options.CallbackPath = "/signin-github";
    
    options.AuthorizationEndpoint = "https://github.com/login/oauth/authorize";
    options.TokenEndpoint = "https://github.com/login/oauth/access_token";
    options.UserInformationEndpoint = "https://api.github.com/user";
    
    options.Scope.Add("user:email");
    
    options.Events = new OAuthEvents
    {
        OnCreatingTicket = async context =>
        {
            // Get user information from GitHub API
            var request = new HttpRequestMessage(HttpMethod.Get, context.Options.UserInformationEndpoint);
            request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", context.AccessToken);
            request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));

            var response = await context.Backchannel.SendAsync(request, context.HttpContext.RequestAborted);
            response.EnsureSuccessStatusCode();

            var user = JsonDocument.Parse(await response.Content.ReadAsStringAsync());
            
            context.RunClaimActions(user.RootElement);
        }
    };
});
```

### Advanced Configuration

```csharp
// JWT Bearer for API Authentication
services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.Authority = "https://demo.identityserver.io";
        options.Audience = "api";
        
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ClockSkew = TimeSpan.Zero
        };
        
        options.Events = new JwtBearerEvents
        {
            OnAuthenticationFailed = context =>
            {
                // Log authentication failures
                Console.WriteLine($"Authentication failed: {context.Exception.Message}");
                return Task.CompletedTask;
            },
            OnTokenValidated = context =>
            {
                // Add custom validation logic
                var claimsIdentity = (ClaimsIdentity)context.Principal.Identity;
                claimsIdentity.AddClaim(new Claim("custom_claim", "value"));
                return Task.CompletedTask;
            }
        };
    });

// Multiple Authentication Schemes
services.AddAuthentication(options =>
{
    options.DefaultScheme = "MultiScheme";
    options.DefaultChallengeScheme = "MultiScheme";
})
.AddPolicyScheme("MultiScheme", "MultiScheme", options =>
{
    options.ForwardDefaultSelector = context =>
    {
        // Determine scheme based on request
        if (context.Request.Headers.ContainsKey("Authorization") &&
            context.Request.Headers["Authorization"].ToString().StartsWith("Bearer "))
        {
            return JwtBearerDefaults.AuthenticationScheme;
        }
        return CookieAuthenticationDefaults.AuthenticationScheme;
    };
})
.AddCookie()
.AddJwtBearer();
```

---

## Comparison Tables

### JWT vs Cookie Authentication

| Aspect | JWT Authentication | Cookie Authentication |
|--------|-------------------|----------------------|
| **Storage** | Client-side (localStorage, sessionStorage) | HTTP-only cookies |
| **Security** | Vulnerable to XSS, secure against CSRF | Vulnerable to CSRF, secure against XSS |
| **Scalability** | Stateless, excellent for distributed systems | Stateful, requires session storage |
| **Mobile Support** | Excellent for mobile apps | Limited for native mobile apps |
| **Token Size** | Larger payload possible | Limited by cookie size restrictions |
| **Revocation** | Difficult to revoke individual tokens | Easy session invalidation |
| **Use Case** | APIs, SPAs, mobile applications | Traditional web applications |

### When to Use What?

**Use JWT when:**
- Building APIs for mobile/SPA clients
- Microservices architecture
- Need stateless authentication
- Cross-domain authentication required

**Use Cookies when:**
- Traditional server-rendered web applications
- Need built-in CSRF protection
- Simpler implementation for web apps
- Session management required

### Role-based vs Policy-based Authorization

| Aspect | Role-based | Policy-based |
|--------|------------|--------------|
| **Complexity** | Simple, straightforward | More complex, flexible |
| **Granularity** | Coarse-grained permissions | Fine-grained control |
| **Maintenance** | Easy for simple scenarios | Better for complex requirements |
| **Dynamic Rules** | Limited static role checks | Complex dynamic requirements |
| **Resource Context** | No resource context | Supports resource-based auth |
| **Use Case** | Simple role hierarchies | Complex business rules |

### OAuth 2.0 vs OpenID Connect

| Aspect | OAuth 2.0 | OpenID Connect |
|--------|-----------|----------------|
| **Purpose** | Authorization framework | Authentication protocol |
| **Tokens** | Access tokens only | ID tokens + access tokens |
| **User Info** | No standard user information | Standardized user claims |
| **Flow** | Authorization code, implicit, etc. | Extends OAuth 2.0 flows |
| **Use Case** | API authorization, delegated access | User authentication, single sign-on |

---

## Interview Questions

### Basic Level Questions

#### 1. What is the difference between authentication and authorization?
**Answer:** 
- **Authentication** verifies who the user is (login process)
- **Authorization** determines what the user can access (permissions)

**Reasoning:** Authentication comes first to establish identity, then authorization controls access based on that identity.

#### 2. What are the main components of a JWT?
**Answer:**
- Header (algorithm and token type)
- Payload (claims/data)
- Signature (verification)

**Reasoning:** The three parts are base64url encoded and separated by dots, with the signature ensuring token integrity.

### Intermediate Level Questions

#### 3. How do you secure JWT tokens against theft?
**Answer:**
- Use HTTPS always
- Set short expiration times
- Implement token refresh mechanism
- Store tokens securely (httpOnly cookies for web)
- Use appropriate token validation

**Reasoning:** JWTs are self-contained, so if stolen, they can be used until expiration. Proper security measures are crucial.

#### 4. What's the difference between `[Authorize]` and `[AllowAnonymous]`?
**Answer:**
- `[Authorize]` requires authentication
- `[AllowAnonymous]` bypasses authentication for specific actions

**Reasoning:** `AllowAnonymous` is useful when you have controller-level authorization but need to exclude specific actions.

### Advanced Level Questions

#### 5. How would you implement a custom authorization requirement that checks business hours?
**Answer:**

```csharp
public class BusinessHoursRequirement : IAuthorizationRequirement
{
    public TimeSpan StartTime { get; }
    public TimeSpan EndTime { get; }

    public BusinessHoursRequirement(TimeSpan start, TimeSpan end)
    {
        StartTime = start;
        EndTime = end;
    }
}

public class BusinessHoursHandler : AuthorizationHandler<BusinessHoursRequirement>
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context,
        BusinessHoursRequirement requirement)
    {
        var now = DateTime.Now.TimeOfDay;
        
        if (now >= requirement.StartTime && now <= requirement.EndTime)
        {
            context.Succeed(requirement);
        }
        
        return Task.CompletedTask;
    }
}
```

**Reasoning:** This demonstrates policy-based authorization with custom business logic.

#### 6. How do you handle token refresh in a secure way?
**Answer:**

```csharp
public class TokenService
{
    public async Task<AuthResult> RefreshTokenAsync(string accessToken, string refreshToken)
    {
        // Validate refresh token from secure storage
        var storedRefreshToken = await _refreshTokenStore.GetAsync(refreshToken);
        
        if (storedRefreshToken == null || storedRefreshToken.IsRevoked ||
            storedRefreshToken.Expires < DateTime.UtcNow)
        {
            throw new SecurityTokenException("Invalid refresh token");
        }

        // Validate old access token (without expiration check)
        var principal = ValidateToken(accessToken, validateLifetime: false);
        
        // Create new tokens
        var newAccessToken = GenerateToken(principal.Claims);
        var newRefreshToken = GenerateRefreshToken();
        
        // Update refresh token store
        await _refreshTokenStore.RevokeAsync(refreshToken);
        await _refreshTokenStore.StoreAsync(newRefreshToken, principal.FindFirstValue(ClaimTypes.NameIdentifier));
        
        return new AuthResult
        {
            AccessToken = newAccessToken,
            RefreshToken = newRefreshToken,
            ExpiresIn = 3600
        };
    }
}
```

**Reasoning:** Secure refresh token implementation prevents token reuse and maintains session security.

### Tricky Questions

#### 7. What happens if you don't validate the JWT signature?
**Answer:** Attackers can modify the token claims and gain unauthorized access. This is a critical security vulnerability.

**Reasoning:** The signature ensures that the token hasn't been tampered with. Without validation, JWTs are essentially unsigned data.

#### 8. Why should you avoid storing sensitive data in JWT payload?
**Answer:** JWTs are base64 encoded, not encrypted. Anyone can decode and read the payload. Use JWE (JSON Web Encryption) for sensitive data.

**Reasoning:** Base64 is easily reversible, so sensitive information like passwords should never be in JWTs.

#### 9. How do you prevent JWT replay attacks?
**Answer:**
- Use short expiration times
- Implement token blacklisting
- Use jti (JWT ID) claims with one-time usage
- Validate audience and issuer claims

**Reasoning:** Replay attacks involve capturing and reusing valid tokens. Proper validation and short lifetimes mitigate this risk.

### Follow-up Questions

#### 10. How would you implement rate limiting based on user claims?
**Answer:**

```csharp
public class RateLimitMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IMemoryCache _cache;

    public RateLimitMiddleware(RequestDelegate next, IMemoryCache cache)
    {
        _next = next;
        _cache = cache;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var user = context.User;
        var rateLimitKey = $"rate_limit_{user.FindFirstValue(ClaimTypes.NameIdentifier)}";
        
        var userRateLimit = user.FindFirst("RateLimit")?.Value ?? "100 per hour";
        var limit = int.Parse(userRateLimit.Split(' ')[0]);
        
        var currentCount = _cache.GetOrCreate(rateLimitKey, entry =>
        {
            entry.AbsoluteExpiration = DateTime.Now.AddHours(1);
            return 0;
        });

        if (currentCount >= limit)
        {
            context.Response.StatusCode = 429;
            await context.Response.WriteAsync("Rate limit exceeded");
            return;
        }

        _cache.Set(rateLimitKey, currentCount + 1);
        await _next(context);
    }
}
```

**Reasoning:** This demonstrates combining authentication claims with application business logic for advanced features.

#### 11. What are the security implications of using the implicit flow in OAuth 2.0?
**Answer:** The implicit flow returns tokens directly in the URL fragment, making them vulnerable to token theft through browser history, referrer headers, or JavaScript access.

**Reasoning:** PKCE (Proof Key for Code Exchange) flow is now recommended for SPAs instead of implicit flow due to better security.

### Scenario-based Questions

#### 12. How would you design an authentication system for a microservices architecture?
**Answer:**
- Use centralized identity provider (OIDC)
- Implement API Gateway for token validation
- Use JWT for stateless authentication
- Implement token introspection for validation
- Use service-to-service authentication with client credentials

```csharp
// API Gateway JWT validation
services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.Authority = "https://auth-service";
        options.Audience = "api-gateway";
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true
        };
    });

// Service-to-service authentication
services.AddHttpClient<ISomeService, SomeService>()
    .AddHttpMessageHandler(() => new ClientCredentialsHandler(
        "https://auth-service/token",
        "client-id",
        "client-secret"));
```

**Reasoning:** Microservices require decentralized yet coordinated authentication that maintains security while allowing scalability.

#### 13. How do you handle authentication in a serverless environment?
**Answer:**
- Use JWT with external identity providers
- Implement custom authorizers (AWS Lambda Authorizers)
- Store user context in request context
- Use managed services like Auth0 or Cognito

```csharp
// AWS Lambda Authorizer example
public class CustomAuthorizer
{
    public async Task<APIGatewayCustomAuthorizerResponse> AuthorizeAsync(
        APIGatewayCustomAuthorizerRequest request)
    {
        var token = request.AuthorizationToken?.Replace("Bearer ", "");
        
        var user = await ValidateJwtTokenAsync(token);
        
        return new APIGatewayCustomAuthorizerResponse
        {
            PrincipalID = user.Id,
            PolicyDocument = new APIGatewayCustomAuthorizerPolicy
            {
                Statement = new List<APIGatewayCustomAuthorizerPolicy.IAMPolicyStatement>
                {
                    new APIGatewayCustomAuthorizerPolicy.IAMPolicyStatement
                    {
                        Effect = "Allow",
                        Resource = new HashSet<string> { request.MethodArn },
                        Action = new HashSet<string> { "execute-api:Invoke" }
                    }
                }
            },
            Context = new Dictionary<string, object>
            {
                ["user"] = JsonSerializer.Serialize(user)
            }
        };
    }
}
```

**Reasoning:** Serverless environments have unique constraints that require stateless, fast authentication mechanisms.

This comprehensive guide covers the depth and breadth of authentication and authorization in modern applications, providing both theoretical understanding and practical implementation knowledge.
