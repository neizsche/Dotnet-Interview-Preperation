# API Design and Versioning - Comprehensive Guide

## Table of Contents
1. [RESTful API Design Principles](#restful-api-design)
2. [API Versioning Strategies](#api-versioning)
3. [Hypermedia and HATEOAS](#hypermedia-hateoas)
4. [API Documentation](#api-documentation)
5. [Comparison Tables](#comparison-tables)
6. [Interview Questions & Answers](#interview-qa)

---

## RESTful API Design Principles {#restful-api-design}

### Core Principles

#### 1. **Client-Server Architecture**
- **Separation of concerns**: UI separated from data storage
- **Statelessness**: Each request contains all necessary information
- **Cacheability**: Responses must define themselves as cacheable or not
- **Layered System**: Client cannot tell if connected to end server or intermediary

#### 2. **Resource-Based Design**
```http
# Good RESTful design
GET    /users          # List users
POST   /users          # Create user
GET    /users/{id}     # Get specific user
PUT    /users/{id}     # Update user (full update)
PATCH  /users/{id}     # Update user (partial update)
DELETE /users/{id}     # Delete user
```

#### 3. **HTTP Methods Semantics**
| Method | Idempotent | Safe | Description |
|--------|------------|------|-------------|
| GET | Yes | Yes | Retrieve resource |
| POST | No | No | Create resource |
| PUT | Yes | No | Replace resource |
| PATCH | No | No | Partial update |
| DELETE | Yes | No | Delete resource |

#### 4. **HTTP Status Codes**
```http
# Success codes
200 OK - Successful GET, PUT, PATCH
201 Created - Successful POST
204 No Content - Successful DELETE

# Client error codes
400 Bad Request - Malformed request
401 Unauthorized - Authentication required
403 Forbidden - Authenticated but no permission
404 Not Found - Resource doesn't exist
409 Conflict - Resource conflict

# Server error codes
500 Internal Server Error - Generic server error
503 Service Unavailable - Temporary overload
```

### Best Practices for .NET Developers

#### 1. **Resource Naming Conventions**
```csharp
// Good examples
/api/users
/api/users/123/orders
/api/products/categories

// Avoid
/api/getUser
/api/updateUser
/api/deleteUser
```

#### 2. **Response Formatting**
```csharp
// Consistent response structure
public class ApiResponse<T>
{
    public bool Success { get; set; }
    public T Data { get; set; }
    public string Message { get; set; }
    public List<string> Errors { get; set; }
}

// In Controller
[HttpGet("{id}")]
public async Task<ActionResult<ApiResponse<UserDto>>> GetUser(int id)
{
    var user = await _userService.GetUserAsync(id);
    if (user == null)
        return NotFound(new ApiResponse<UserDto> 
        { 
            Success = false, 
            Message = "User not found" 
        });
    
    return Ok(new ApiResponse<UserDto> 
    { 
        Success = true, 
        Data = user 
    });
}
```

#### 3. **Error Handling**
```csharp
// Global exception handling
public class CustomExceptionHandler : IExceptionHandler
{
    public async ValueTask<bool> TryHandleAsync(
        HttpContext httpContext,
        Exception exception,
        CancellationToken cancellationToken)
    {
        var (statusCode, message) = exception switch
        {
            ValidationException => (StatusCodes.Status400BadRequest, "Validation failed"),
            NotFoundException => (StatusCodes.Status404NotFound, "Resource not found"),
            _ => (StatusCodes.Status500InternalServerError, "Internal server error")
        };
        
        httpContext.Response.StatusCode = statusCode;
        await httpContext.Response.WriteAsJsonAsync(new { error = message });
        return true;
    }
}
```

---

## API Versioning Strategies {#api-versioning}

### 1. **URL Versioning**
```http
GET /api/v1/users
GET /api/v2/users
```

**Implementation in .NET:**
```csharp
[ApiVersion("1.0")]
[Route("api/v{version:apiVersion}/[controller]")]
public class UsersController : ControllerBase
{
    [HttpGet]
    public IActionResult GetUsers() => Ok("Version 1.0");
}

[ApiVersion("2.0")]
[Route("api/v{version:apiVersion}/[controller]")]
public class UsersV2Controller : ControllerBase
{
    [HttpGet]
    public IActionResult GetUsers() => Ok("Version 2.0 with enhanced features");
}
```

### 2. **Header Versioning**
```http
GET /api/users
Headers: api-version: 2.0
```

**Implementation:**
```csharp
services.AddApiVersioning(options =>
{
    options.ApiVersionReader = new HeaderApiVersionReader("api-version");
    options.AssumeDefaultVersionWhenUnspecified = true;
    options.DefaultApiVersion = new ApiVersion(1, 0);
});
```

### 3. **Query String Versioning**
```http
GET /api/users?version=2.0
```

**Implementation:**
```csharp
services.AddApiVersioning(options =>
{
    options.ApiVersionReader = new QueryStringApiVersionReader("version");
});
```

### 4. **Media Type Versioning (Content Negotiation)**
```http
GET /api/users
Accept: application/vnd.company.v2+json
```

---

## Hypermedia and HATEOAS {#hypermedia-hateoas}

### Concept Overview
HATEOAS (Hypermedia as the Engine of Application State) means clients interact with the API entirely through hypermedia provided dynamically by application servers.

### Implementation Example

```csharp
public class Resource<T>
{
    public T Data { get; set; }
    public List<Link> Links { get; set; } = new List<Link>();
}

public class Link
{
    public string Href { get; set; }
    public string Rel { get; set; }
    public string Method { get; set; }
}

// HATEOAS implementation
[HttpGet("{id}")]
public ActionResult<Resource<UserDto>> GetUser(int id)
{
    var user = _userService.GetUser(id);
    if (user == null) return NotFound();
    
    var resource = new Resource<UserDto> { Data = user };
    
    // Add links
    resource.Links.Add(new Link 
    { 
        Href = Url.Link("GetUser", new { id }), 
        Rel = "self", 
        Method = "GET" 
    });
    
    resource.Links.Add(new Link 
    { 
        Href = Url.Link("UpdateUser", new { id }), 
        Rel = "update", 
        Method = "PUT" 
    });
    
    resource.Links.Add(new Link 
    { 
        Href = Url.Link("DeleteUser", new { id }), 
        Rel = "delete", 
        Method = "DELETE" 
    });
    
    return resource;
}
```

### Response Example
```json
{
    "data": {
        "id": 1,
        "name": "John Doe",
        "email": "john@example.com"
    },
    "links": [
        {
            "href": "/api/users/1",
            "rel": "self",
            "method": "GET"
        },
        {
            "href": "/api/users/1",
            "rel": "update",
            "method": "PUT"
        },
        {
            "href": "/api/users/1",
            "rel": "delete",
            "method": "DELETE"
        }
    ]
}
```

---

## API Documentation with Swagger/OpenAPI {#api-documentation}

### Setup in .NET

```csharp
// Program.cs
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo 
    { 
        Title = "My API", 
        Version = "v1",
        Description = "API Description",
        Contact = new OpenApiContact { Name = "Support", Email = "support@company.com" }
    });
    
    // Include XML comments
    var xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
    var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
    c.IncludeXmlComments(xmlPath);
    
    // Add JWT Bearer authentication
    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        Description = "JWT Authorization header using the Bearer scheme",
        Name = "Authorization",
        In = ParameterLocation.Header,
        Type = SecuritySchemeType.ApiKey,
        Scheme = "Bearer"
    });
});

app.UseSwagger();
app.UseSwaggerUI(c =>
{
    c.SwaggerEndpoint("/swagger/v1/swagger.json", "My API V1");
});
```

### API Documentation Best Practices

```csharp
[ApiController]
[Route("api/[controller]")]
[Produces("application/json")]
public class UsersController : ControllerBase
{
    /// <summary>
    /// Retrieves a specific user by unique id
    /// </summary>
    /// <param name="id">User unique identifier</param>
    /// <returns>User details</returns>
    /// <response code="200">Returns the user</response>
    /// <response code="404">User not found</response>
    [HttpGet("{id}")]
    [ProducesResponseType(typeof(UserDto), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<ActionResult<UserDto>> GetUser(int id)
    {
        // Implementation
    }
    
    /// <summary>
    /// Creates a new user
    /// </summary>
    /// <param name="userDto">User creation data</param>
    /// <returns>Created user</returns>
    /// <response code="201">User created successfully</response>
    /// <response code="400">Invalid input data</response>
    [HttpPost]
    [ProducesResponseType(typeof(UserDto), StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public async Task<ActionResult<UserDto>> CreateUser([FromBody] CreateUserDto userDto)
    {
        // Implementation
    }
}
```

---

## Comparison Tables {#comparison-tables}

### API Versioning Strategies Comparison

| Strategy | Pros | Cons | When to Use |
|----------|------|------|-------------|
| **URL Versioning** | - Simple to implement<br>- Easy to debug<br>- Clear in browser | - Breaks URL consistency<br>- Not RESTful purist | - Public APIs<br>- When clients need explicit version visibility |
| **Header Versioning** | - Clean URLs<br>- RESTful compliant<br>- No URL changes | - Harder to debug<br>- Requires client awareness | - Internal APIs<br>- Mobile applications |
| **Query Parameter** | - Easy to implement<br>- Browser testable | - Not standard<br>- Caching issues | - Quick prototypes<br>- Limited versioning needs |
| **Media Type** | - Most RESTful<br>- Content negotiation | - Complex implementation<br>- Limited tooling support | - Hypermedia APIs<br>- Advanced REST implementations |

### HTTP Methods Comparison

| Method | Idempotent | Safe | Request Body | Response Body | Typical Use |
|--------|------------|------|--------------|---------------|-------------|
| **GET** | Yes | Yes | No | Yes | Retrieve resources |
| **POST** | No | No | Yes | Yes | Create new resources |
| **PUT** | Yes | No | Yes | Yes | Replace entire resource |
| **PATCH** | No | No | Yes | Yes | Partial resource update |
| **DELETE** | Yes | No | No | Optional | Remove resource |

### Response Status Codes Guide

| Code Range | Category | Common Codes | Usage |
|------------|----------|--------------|-------|
| 2xx | Success | 200, 201, 204 | Successful operations |
| 3xx | Redirection | 301, 304 | Caching and redirects |
| 4xx | Client Error | 400, 401, 403, 404, 409 | Client-side issues |
| 5xx | Server Error | 500, 502, 503 | Server-side failures |

---

## Interview Questions & Answers {#interview-qa}

### Basic to Intermediate Questions

#### Q1: What are the key principles of RESTful API design?
**Answer:**
- **Statelessness**: Each request contains all necessary information
- **Client-Server Architecture**: Separation of concerns
- **Cacheability**: Responses define caching capabilities
- **Uniform Interface**: Consistent resource identification and manipulation
- **Layered System**: Architecture with multiple hierarchical layers

**Reasoning**: These principles ensure scalability, reliability, and maintainability of APIs.

#### Q2: What's the difference between PUT and PATCH?
**Answer:**
- **PUT**: Replaces the entire resource (idempotent)
- **PATCH**: Partially updates specific fields (not idempotent)

**Example:**
```http
PUT /users/1
{
    "name": "John",
    "email": "john@new.com"
}
# Replaces entire user resource

PATCH /users/1
{
    "email": "john@new.com"
}
# Updates only email field
```

**Reasoning**: PUT requires sending complete resource representation, while PATCH allows partial updates, reducing bandwidth usage.

#### Q3: When would you use 400 vs 422 status codes?
**Answer:**
- **400 Bad Request**: Malformed request syntax, missing required parameters
- **422 Unprocessable Entity**: Syntax valid but semantic errors (validation failures)

**Example:**
```http
# 400 - Missing required field
POST /users
{
    "name": "John"
}
# email field is required but missing

# 422 - Validation error
POST /users
{
    "name": "John",
    "email": "invalid-email"
}
# Email format is invalid
```

**Reasoning**: 400 indicates the request itself is invalid, while 422 means the request is syntactically correct but contains business logic errors.

### Advanced/Tricky Questions

#### Q4: What are the trade-offs between different API versioning strategies?
**Answer:**

**URL Versioning Trade-offs:**
- ✅ Easy to understand and debug
- ✅ Clear version visibility
- ❌ Breaks URL permanence
- ❌ Not truly RESTful

**Header Versioning Trade-offs:**
- ✅ Clean, permanent URLs
- ✅ More RESTful compliant
- ❌ Harder to test in browsers
- ❌ Requires client cooperation

**Reasoning**: The choice depends on API consumers, tooling support, and REST compliance requirements.

#### Q5: How does HATEOAS improve API discoverability, and what are its practical challenges?
**Answer:**

**Benefits:**
- Self-descriptive APIs
- Client doesn't need hardcoded URLs
- Dynamic workflow adaptation

**Challenges:**
- Increased response size
- Complex implementation
- Limited client support
- Steeper learning curve

**Practical Example:**
```json
{
    "data": { "id": 1, "status": "pending" },
    "links": [
        {"rel": "approve", "href": "/orders/1/approve", "method": "POST"},
        {"rel": "reject", "href": "/orders/1/reject", "method": "POST"}
    ]
}
```

**Reasoning**: HATEOAS works well for complex workflows but might be overkill for simple CRUD APIs.

#### Q6: What's the difference between authentication and authorization in API context?
**Answer:**

**Authentication (WHO you are):**
- Verifies user identity
- Examples: JWT tokens, API keys, OAuth
- Status codes: 401 Unauthorized

**Authorization (WHAT you can do):**
- Checks permissions for specific actions
- Examples: Role-based access, permissions
- Status codes: 403 Forbidden

**Implementation:**
```csharp
[Authorize] // Authentication
public class UsersController : ControllerBase
{
    [HttpGet("{id}")]
    [RequiredPermission(Permission.ReadUser)] // Authorization
    public IActionResult GetUser(int id) { ... }
}
```

**Reasoning**: Authentication happens before authorization in the request pipeline.

### Follow-up Questions

#### Q7: How do you handle breaking changes in APIs?
**Answer:**
**Strategies:**
1. **Versioning**: Introduce new API version
2. **Expand-Contract**: Add new fields without removing old ones
3. **Deprecation Policy**: Communicate timeline for breaking changes
4. **Feature Toggles**: Control changes via configuration

**Example:**
```csharp
// Version 1 - Old structure
public class UserV1
{
    public string Name { get; set; }
}

// Version 2 - New structure with backward compatibility
public class UserV2
{
    [Obsolete("Use FirstName and LastName instead")]
    public string Name { get; set; }
    
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
```

**Reasoning**: Breaking changes should be managed carefully to avoid disrupting existing clients.

#### Q8: What are the best practices for API pagination?
**Answer:**
**Common Patterns:**
1. **Offset-based**: `?page=2&size=20`
2. **Cursor-based**: `?cursor=abc123&size=20`
3. **Keyset-based**: `?last_id=100&size=20`

**Implementation:**
```csharp
public class PagedResponse<T>
{
    public List<T> Data { get; set; }
    public int PageNumber { get; set; }
    public int PageSize { get; set; }
    public int TotalRecords { get; set; }
    public int TotalPages => (int)Math.Ceiling(TotalRecords / (double)PageSize);
    public bool HasPrevious => PageNumber > 1;
    public bool HasNext => PageNumber < TotalPages;
}

[HttpGet]
public async Task<ActionResult<PagedResponse<UserDto>>> GetUsers(
    [FromQuery] int page = 1, 
    [FromQuery] int size = 20)
{
    var result = await _userService.GetPagedUsersAsync(page, size);
    return Ok(result);
}
```

**Reasoning**: Cursor-based pagination performs better for large datasets as it doesn't require counting total records.

### .NET Specific Questions

#### Q9: How do you implement API versioning in ASP.NET Core?
**Answer:**
```csharp
// Startup configuration
services.AddApiVersioning(options =>
{
    options.DefaultApiVersion = new ApiVersion(1, 0);
    options.AssumeDefaultVersionWhenUnspecified = true;
    options.ReportApiVersions = true;
    options.ApiVersionReader = ApiVersionReader.Combine(
        new QueryStringApiVersionReader("api-version"),
        new HeaderApiVersionReader("x-api-version")
    );
});

// Controller implementation
[ApiVersion("1.0")]
[ApiVersion("2.0")]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    [MapToApiVersion("1.0")]
    [HttpGet]
    public IActionResult GetV1() => Ok("Version 1.0");
    
    [MapToApiVersion("2.0")]
    [HttpGet]
    public IActionResult GetV2() => Ok("Version 2.0");
}
```

**Reasoning**: ASP.NET Core provides flexible versioning options that can be combined for different scenarios.

#### Q10: What's the difference between `[ApiController]` attribute and regular ControllerBase?
**Answer:**

**`[ApiController]` provides:**
- Automatic HTTP 400 responses for invalid models
- Attribute routing requirement
- Binding source parameter inference
- Problem details for error responses

**Example:**
```csharp
[ApiController] // Enables automatic validation
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    [HttpPost]
    public IActionResult CreateUser(CreateUserDto dto)
    {
        // ModelState.IsValid is automatically checked
        // Returns 400 automatically if invalid
    }
}
```

**Reasoning**: `[ApiController]` reduces boilerplate code and enforces API-specific conventions.

### Performance and Security Questions

#### Q11: How do you prevent N+1 query problem in REST APIs?
**Answer:**
**Problem:**
```csharp
// Bad - N+1 queries
var users = _context.Users.ToList();
foreach (var user in users)
{
    var orders = _context.Orders.Where(o => o.UserId == user.Id).ToList();
}
```

**Solution - Eager Loading:**
```csharp
// Good - Single query with join
var usersWithOrders = _context.Users
    .Include(u => u.Orders)
    .Select(u => new UserDto
    {
        Id = u.Id,
        Name = u.Name,
        Orders = u.Orders.Select(o => new OrderDto 
        {
            Id = o.Id,
            Amount = o.Amount
        }).ToList()
    })
    .ToList();
```

**Reasoning**: Eager loading or projection reduces database round trips, improving performance significantly.

#### Q12: What security measures are essential for REST APIs?
**Answer:**
**Essential Security Layers:**
1. **Authentication**: JWT, OAuth 2.0
2. **Authorization**: Role-based access control
3. **HTTPS**: Encrypt all communications
4. **Input Validation**: Prevent injection attacks
5. **Rate Limiting**: Prevent abuse
6. **CORS**: Control cross-origin requests

**Implementation:**
```csharp
services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true
        };
    });

services.AddAuthorization(options =>
{
    options.AddPolicy("AdminOnly", policy => 
        policy.RequireRole("Admin"));
});
```

**Reasoning**: Defense in depth approach with multiple security layers provides comprehensive protection.

### Real-world Scenario Questions

#### Q13: How would you design an API for a e-commerce system?
**Answer:**
**Resource Design:**
```
/products          # Product catalog
/products/{id}     # Specific product
/categories        # Product categories
/users             # User management
/users/{id}/orders # User orders
/orders            # Order management
/orders/{id}       # Specific order
/payments          # Payment processing
```

**Key Considerations:**
- RESTful resource modeling
- Proper status codes (201 Created for orders)
- Idempotency for payments
- Pagination for product listings
- Caching strategies for products

**Reasoning**: E-commerce APIs need to balance performance, security, and business logic complexity.

#### Q14: What strategies would you use for API rate limiting?
**Answer:**
**Common Strategies:**
1. **Fixed Window**: Requests per fixed time period
2. **Sliding Window**: More granular time-based limiting
3. **Token Bucket**: Dynamic rate adjustment
4. **User-based**: Different limits for different user types

**Implementation with .NET:**
```csharp
services.AddRateLimiting(options =>
{
    options.AddFixedWindowLimiter("Fixed", opt =>
    {
        opt.PermitLimit = 100;
        opt.Window = TimeSpan.FromMinutes(1);
    });
});

[EnableRateLimiting("Fixed")]
public class ProductsController : ControllerBase
{
    // Controller actions
}
```

**Reasoning**: Rate limiting protects against abuse and ensures fair resource distribution.

This comprehensive guide covers all aspects of API design and versioning with practical .NET examples. The interview questions range from basic to advanced, covering both theoretical concepts and practical implementation details.
