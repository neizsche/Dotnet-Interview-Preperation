# Architectural Patterns - Comprehensive Guide

## 1. Repository Pattern and Unit of Work

### Surface Level Knowledge
The **Repository Pattern** abstracts data access logic, providing a collection-like interface for domain objects. **Unit of Work** maintains a list of objects affected by a business transaction and coordinates writing out changes.

### Deep Understanding

#### Repository Pattern
```csharp
public interface IRepository<T> where T : class
{
    T GetById(int id);
    IEnumerable<T> GetAll();
    void Add(T entity);
    void Update(T entity);
    void Delete(T entity);
}

public class UserRepository : IRepository<User>
{
    private readonly DbContext _context;
    
    public UserRepository(DbContext context)
    {
        _context = context;
    }
    
    public User GetById(int id) => _context.Set<User>().Find(id);
    public void Add(User user) => _context.Set<User>().Add(user);
    // ... other implementations
}
```

#### Unit of Work Pattern
```csharp
public interface IUnitOfWork : IDisposable
{
    IRepository<User> Users { get; }
    IRepository<Order> Orders { get; }
    int Commit();
    Task<int> CommitAsync();
}

public class UnitOfWork : IUnitOfWork
{
    private readonly DbContext _context;
    private Dictionary<Type, object> _repositories;
    
    public UnitOfWork(DbContext context)
    {
        _context = context;
        _repositories = new Dictionary<Type, object>();
    }
    
    public IRepository<T> GetRepository<T>() where T : class
    {
        if (_repositories.ContainsKey(typeof(T)))
            return (IRepository<T>)_repositories[typeof(T)];
            
        var repository = new Repository<T>(_context);
        _repositories.Add(typeof(T), repository);
        return repository;
    }
    
    public int Commit() => _context.SaveChanges();
}
```

### Key Benefits
- **Decoupling**: Business logic doesn't depend on data access implementation
- **Testability**: Easy to mock repositories for unit testing
- **Maintainability**: Centralized data access logic
- **Flexibility**: Easy to switch data sources

### When to Use
- ✅ Complex domain models with multiple aggregates
- ✅ Need for testable business logic
- ✅ Multiple data sources (SQL, NoSQL, APIs)
- ✅ Complex query requirements

### When NOT to Use
- ❌ Simple CRUD applications
- ❌ When using ORM directly suffices
- ❌ Microservices with simple data needs

---

## 2. Specification Pattern

### Surface Level Knowledge
Encapsulates business rules that determine whether an object meets certain criteria, reusable across different parts of the application.

### Deep Understanding

```csharp
public interface ISpecification<T>
{
    Expression<Func<T, bool>> Criteria { get; }
    List<Expression<Func<T, object>>> Includes { get; }
    List<string> IncludeStrings { get; }
    Expression<Func<T, object>> OrderBy { get; }
    Expression<Func<T, object>> OrderByDescending { get; }
}

public abstract class BaseSpecification<T> : ISpecification<T>
{
    public Expression<Func<T, bool>> Criteria { get; }
    public List<Expression<Func<T, object>>> Includes { get; } = new();
    public List<string> IncludeStrings { get; } = new();
    public Expression<Func<T, object>> OrderBy { get; private set; }
    public Expression<Func<T, object>> OrderByDescending { get; private set; }

    protected BaseSpecification(Expression<Func<T, bool>> criteria)
    {
        Criteria = criteria;
    }

    protected void AddInclude(Expression<Func<T, object>> includeExpression)
    {
        Includes.Add(includeExpression);
    }
    
    protected void AddOrderBy(Expression<Func<T, object>> orderByExpression)
    {
        OrderBy = orderByExpression;
    }
}

// Usage
public class ActiveUsersWithOrdersSpecification : BaseSpecification<User>
{
    public ActiveUsersWithOrdersSpecification() 
        : base(u => u.IsActive && u.Orders.Any(o => o.TotalAmount > 100))
    {
        AddInclude(u => u.Orders);
        AddInclude(u => u.Profile);
        AddOrderBy(u => u.CreatedDate);
    }
}
```

### Composite Specifications
```csharp
public class AndSpecification<T> : BaseSpecification<T>
{
    public AndSpecification(ISpecification<T> left, ISpecification<T> right)
        : base(CombineCriteria(left, right))
    {
        // Combine includes from both specifications
    }
    
    private static Expression<Func<T, bool>> CombineCriteria(
        ISpecification<T> left, ISpecification<T> right)
    {
        var param = Expression.Parameter(typeof(T));
        var combined = Expression.AndAlso(
            Expression.Invoke(left.Criteria, param),
            Expression.Invoke(right.Criteria, param)
        );
        return Expression.Lambda<Func<T, bool>>(combined, param);
    }
}
```

### When to Use
- ✅ Complex query logic reuse
- ✅ Business rules that apply to multiple entities
- ✅ Dynamic query building
- ✅ Separation of query concerns from repositories

---

## 3. Mediator Pattern (MediatR)

### Surface Level Knowledge
Mediator promotes loose coupling by preventing objects from referring to each other explicitly, allowing their interaction to be varied independently.

### Deep Understanding with MediatR

```csharp
// Commands
public class CreateUserCommand : IRequest<int>
{
    public string Email { get; set; }
    public string Name { get; set; }
}

public class CreateUserCommandHandler : IRequestHandler<CreateUserCommand, int>
{
    private readonly IUserRepository _repository;
    
    public CreateUserCommandHandler(IUserRepository repository)
    {
        _repository = repository;
    }
    
    public async Task<int> Handle(CreateUserCommand request, CancellationToken ct)
    {
        var user = new User { Email = request.Email, Name = request.Name };
        _repository.Add(user);
        await _repository.SaveChangesAsync(ct);
        return user.Id;
    }
}

// Queries
public class GetUserQuery : IRequest<UserDto>
{
    public int UserId { get; set; }
}

public class GetUserQueryHandler : IRequestHandler<GetUserQuery, UserDto>
{
    public async Task<UserDto> Handle(GetUserQuery request, CancellationToken ct)
    {
        // Implementation
        return await Task.FromResult(new UserDto());
    }
}

// Notifications (Publish/Subscribe)
public class UserCreatedNotification : INotification
{
    public int UserId { get; set; }
    public string Email { get; set; }
}

public class EmailNotificationHandler : INotificationHandler<UserCreatedNotification>
{
    public async Task Handle(UserCreatedNotification notification, CancellationToken ct)
    {
        // Send welcome email
        await Task.CompletedTask;
    }
}

public class AuditNotificationHandler : INotificationHandler<UserCreatedNotification>
{
    public async Task Handle(UserCreatedNotification notification, CancellationToken ct)
    {
        // Log audit trail
        await Task.CompletedTask;
    }
}
```

### Pipeline Behaviors (Middleware)
```csharp
public class LoggingBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
{
    private readonly ILogger<LoggingBehavior<TRequest, TResponse>> _logger;
    
    public LoggingBehavior(ILogger<LoggingBehavior<TRequest, TResponse>> logger)
    {
        _logger = logger;
    }
    
    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken ct)
    {
        _logger.LogInformation($"Handling {typeof(TRequest).Name}");
        var response = await next();
        _logger.LogInformation($"Handled {typeof(TRequest).Name}");
        return response;
    }
}
```

### When to Use
- ✅ Complex object interactions
- ✅ Need to reduce dependencies between components
- ✅ Implementing CQRS
- ✅ Cross-cutting concerns (logging, validation, caching)

---

## 4. CQRS (Command Query Responsibility Segregation)

### Surface Level Knowledge
CQRS separates read and write operations into different models, using commands for writes and queries for reads.

### Deep Understanding

#### Basic Architecture
```
Commands → Command Handlers → Write Model → Event Publishing
Queries → Query Handlers → Read Model (Denormalized)
```

#### Implementation
```csharp
// Commands Side
public class UpdateProductPriceCommand : IRequest
{
    public int ProductId { get; set; }
    public decimal NewPrice { get; set; }
}

public class UpdateProductPriceCommandHandler : IRequestHandler<UpdateProductPriceCommand>
{
    private readonly IProductRepository _repository;
    
    public async Task<Unit> Handle(UpdateProductPriceCommand request, CancellationToken ct)
    {
        var product = await _repository.GetByIdAsync(request.ProductId);
        product.UpdatePrice(request.NewPrice);
        await _repository.SaveChangesAsync(ct);
        return Unit.Value;
    }
}

// Queries Side
public class GetProductsQuery : IRequest<List<ProductDto>>
{
    public decimal? MinPrice { get; set; }
    public decimal? MaxPrice { get; set; }
}

public class GetProductsQueryHandler : IRequestHandler<GetProductsQuery, List<ProductDto>>
{
    private readonly IProductReadRepository _readRepository;
    
    public async Task<List<ProductDto>> Handle(GetProductsQuery request, CancellationToken ct)
    {
        return await _readRepository.GetProductsAsync(request.MinPrice, request.MaxPrice);
    }
}

// Separate Read Model
public class ProductDto
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
    public string CategoryName { get; set; } // Denormalized
}
```

#### Advanced CQRS with Event Sourcing
```csharp
public abstract class AggregateRoot
{
    private readonly List<IDomainEvent> _changes = new();
    
    public Guid Id { get; protected set; }
    public int Version { get; protected set; }
    
    public IReadOnlyCollection<IDomainEvent> GetUncommittedChanges() => _changes.AsReadOnly();
    
    public void MarkChangesAsCommitted() => _changes.Clear();
    
    protected void ApplyChange(IDomainEvent @event, bool isNew = true)
    {
        Apply(@event);
        if (isNew) _changes.Add(@event);
    }
    
    protected abstract void Apply(IDomainEvent @event);
}
```

### When to Use
- ✅ High-performance applications
- ✅ Complex business logic
- ✅ Different read/write scalability needs
- ✅ Collaborative domains (multiple users)

---

## 5. Event Sourcing

### Surface Level Knowledge
Instead of storing current state, store the sequence of events that led to the current state. Rebuild state by replaying events.

### Deep Understanding

#### Basic Implementation
```csharp
public interface IEventStore
{
    Task SaveEventsAsync(Guid aggregateId, IEnumerable<IDomainEvent> events, int expectedVersion);
    Task<List<IDomainEvent>> GetEventsForAggregateAsync(Guid aggregateId);
}

public class EventStore : IEventStore
{
    private readonly Dictionary<Guid, List<IDomainEvent>> _eventStore = new();
    
    public async Task SaveEventsAsync(Guid aggregateId, IEnumerable<IDomainEvent> events, int expectedVersion)
    {
        if (!_eventStore.ContainsKey(aggregateId))
            _eventStore[aggregateId] = new List<IDomainEvent>();
            
        var currentVersion = _eventStore[aggregateId].Count - 1;
        if (currentVersion != expectedVersion)
            throw new ConcurrencyException();
            
        _eventStore[aggregateId].AddRange(events);
        await Task.CompletedTask;
    }
    
    public async Task<List<IDomainEvent>> GetEventsForAggregateAsync(Guid aggregateId)
    {
        if (_eventStore.ContainsKey(aggregateId))
            return await Task.FromResult(_eventStore[aggregateId]);
        return await Task.FromResult(new List<IDomainEvent>());
    }
}

// Aggregate implementation
public class BankAccount : AggregateRoot
{
    public decimal Balance { get; private set; }
    public bool IsClosed { get; private set; }
    
    public BankAccount() { }
    
    public BankAccount(Guid id, string accountHolder)
    {
        ApplyChange(new AccountCreatedEvent(id, accountHolder, DateTime.UtcNow));
    }
    
    public void Deposit(decimal amount)
    {
        if (IsClosed) throw new AccountClosedException();
        ApplyChange(new MoneyDepositedEvent(Id, amount, DateTime.UtcNow));
    }
    
    protected override void Apply(IDomainEvent @event)
    {
        switch (@event)
        {
            case AccountCreatedEvent e:
                Id = e.AccountId;
                Balance = 0;
                break;
            case MoneyDepositedEvent e:
                Balance += e.Amount;
                break;
        }
    }
}
```

#### Projections (Read Model Builders)
```csharp
public class BankAccountProjection
{
    private readonly Dictionary<Guid, BankAccountView> _views = new();
    
    public void Handle(AccountCreatedEvent @event)
    {
        _views[@event.AccountId] = new BankAccountView
        {
            AccountId = @event.AccountId,
            AccountHolder = @event.AccountHolder,
            Balance = 0,
            CreatedDate = @event.CreatedDate
        };
    }
    
    public void Handle(MoneyDepositedEvent @event)
    {
        if (_views.ContainsKey(@event.AccountId))
        {
            _views[@event.AccountId].Balance += @event.Amount;
            _views[@event.AccountId].LastTransactionDate = @event.DepositDate;
        }
    }
}
```

### When to Use
- ✅ Audit trail requirements
- ✅ Complex business logic with temporal queries
- ✅ Need for event replayability
- ✅ Systems requiring high reliability

---

## Pattern Comparison Table

| Pattern | Primary Purpose | Complexity | Use Cases | Performance Impact |
|---------|-----------------|------------|-----------|-------------------|
| **Repository + UoW** | Data access abstraction | Medium | Complex domains, testability | Minimal overhead |
| **Specification** | Query encapsulation | Low-Medium | Reusable business rules | Can optimize queries |
| **Mediator** | Decoupled communication | Medium | CQRS, cross-cutting concerns | Slight overhead |
| **CQRS** | Read/write separation | High | High performance, complex logic | Significant improvement |
| **Event Sourcing** | Event-based state storage | Very High | Audit trails, temporal queries | High read complexity |

---

## Probable Questions & Answers

### Repository Pattern Questions

**Q1: What's the difference between Repository and DAO patterns?**
**A:** Repository works with domain objects and business concepts, while DAO works with data storage concepts. Repository is more domain-centric, DAO is more data-centric.

**Q2: When should you avoid Repository pattern with Entity Framework?**
**A:** When EF DbContext already implements Unit of Work and Repository patterns. Adding another abstraction layer might be over-engineering.

**Q3: How do you handle complex queries in Repository pattern?**
**A:** Use Specification pattern or expose IQueryable (though this leaks persistence concerns).

```csharp
// Option 1: Specification
public interface IRepository<T>
{
    IEnumerable<T> Find(ISpecification<T> spec);
}

// Option 2: Queryable (leaky abstraction)
IQueryable<T> GetQueryable();
```

### Unit of Work Questions

**Q1: What happens if Commit() fails in the middle of a transaction?**
**A:** The entire transaction rolls back. Unit of Work should implement atomicity - all changes succeed or none do.

**Q2: How do you handle concurrent modifications?**
**A:** Use optimistic concurrency with versioning or pessimistic locking depending on requirements.

```csharp
public class Entity
{
    public int Id { get; set; }
    public byte[] Version { get; set; } // For optimistic concurrency
}
```

### Specification Pattern Questions

**Q1: How do you combine multiple specifications?**
**A:** Use composite specifications (AndSpecification, OrSpecification) that combine criteria.

**Q2: What about performance with many includes?**
**A:** Be careful with eager loading. Use projection or explicit loading for complex scenarios.

### Mediator Pattern Questions

**Q1: What are the disadvantages of Mediator pattern?**
**A:** 
- Debugging can be harder (indirection)
- Performance overhead
- Learning curve for teams
- Can lead to anemic domain models if overused

**Q2: How do you handle transactions across multiple handlers?**
**A:** Use pipeline behaviors to wrap handlers in transactions:

```csharp
public class TransactionBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
{
    private readonly DbContext _context;
    
    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken ct)
    {
        using var transaction = await _context.Database.BeginTransactionAsync(ct);
        try
        {
            var response = await next();
            await transaction.CommitAsync(ct);
            return response;
        }
        catch
        {
            await transaction.RollbackAsync(ct);
            throw;
        }
    }
}
```

### CQRS Questions

**Q1: When is CQRS overkill?**
**A:** For simple CRUD applications, when read/write models are nearly identical, or when team lacks experience with distributed systems.

**Q2: How do you handle eventual consistency?**
**A:** 
- Use compensating actions for failures
- Implement retry mechanisms
- Provide user feedback about processing state
- Use sagas for complex workflows

**Q3: What about data duplication in read models?**
**A:** It's acceptable in CQRS. Read models are optimized for queries and can denormalize data from multiple aggregates.

### Event Sourcing Questions

**Q1: How do you handle schema changes in stored events?**
**A:** 
- Version events and implement upcasters
- Never change existing events, only add new versions
- Use event migration strategies for major changes

**Q2: What's the performance impact of rebuilding state from events?**
**A:** Significant for large event streams. Use snapshots to store state at certain points:

```csharp
public interface ISnapshotStore
{
    Task<Snapshot> GetSnapshotAsync(Guid aggregateId);
    Task SaveSnapshotAsync(Guid aggregateId, Snapshot snapshot);
}

public class Snapshot
{
    public Guid AggregateId { get; set; }
    public int Version { get; set; }
    public string Data { get; set; } // Serialized state
    public DateTime CreatedAt { get; set; }
}
```

**Q3: How do you handle event ordering and concurrency?**
**A:** Use versioning and optimistic concurrency control. Each event has a sequence number.

### Tricky Follow-up Questions

**Q: Can you combine all these patterns in one application?**
**A:** Yes, but carefully. Example architecture:
- Commands/Queries using MediatR
- Repositories with Specification pattern for data access
- CQRS separation for complex domains
- Event Sourcing for critical aggregates

**Q: What about testing strategies for these patterns?**
**A:** 
- Repository: Mock the repository interface
- Mediator: Test handlers in isolation
- CQRS: Test command/query handlers separately
- Event Sourcing: Test aggregate behavior by applying events

**Q: How do you handle errors and exceptions in these patterns?**
**A:** 
- Use pipeline behaviors for exception handling
- Implement custom exception types for domain errors
- Use result patterns instead of exceptions for expected failures

```csharp
public class Result<T>
{
    public bool IsSuccess { get; }
    public T Value { get; }
    public string Error { get; }
    
    public static Result<T> Success(T value) => new Result<T>(true, value, null);
    public static Result<T> Failure(string error) => new Result<T>(false, default, error);
}
```

This comprehensive guide covers the essential aspects of these architectural patterns with practical examples and addressing common challenges you might encounter in real-world applications.
