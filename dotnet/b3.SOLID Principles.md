# SOLID Principles: Comprehensive Guide

## Table of Contents
1. [Introduction to SOLID Principles](#introduction)
2. [Single Responsibility Principle (SRP)](#srp)
3. [Open/Closed Principle (OCP)](#ocp)
4. [Liskov Substitution Principle (LSP)](#lsp)
5. [Interface Segregation Principle (ISP)](#isp)
6. [Dependency Inversion Principle (DIP)](#dip)
7. [Comparative Analysis](#comparative-analysis)
8. [Interview Questions & Answers](#interview-qa)

---

## Introduction to SOLID Principles <a name="introduction"></a>

SOLID is an acronym for five object-oriented design principles that help create maintainable, scalable, and flexible software. Introduced by Robert C. Martin (Uncle Bob), these principles have become fundamental to modern software development.

## 1. Single Responsibility Principle (SRP) <a name="srp"></a>

### Surface Level Knowledge
**"A class should have only one reason to change"** - meaning each class should have only one responsibility or job.

### Deep Understanding

#### Core Concept
SRP states that a module, class, or function should be responsible for only one aspect of the software's functionality. This doesn't mean "one method per class" but rather "one axis of change."

#### Key Indicators of SRP Violation
- **God Classes**: Classes that know/do too much
- **Multiple reasons to change**: If requirements in different domains affect the same class
- **Tight coupling**: Class dependencies span multiple concerns

#### Code Examples

**Violation Example:**
```java
class Employee {
    public void calculateSalary() { /* business logic */ }
    public void saveToDatabase() { /* database logic */ }
    public void generateReport() { /* reporting logic */ }
    public void sendEmail() { /* notification logic */ }
}
```

**SRP Compliant Solution:**
```java
class Employee {
    public void calculateSalary() { /* business logic */ }
}

class EmployeeRepository {
    public void save(Employee employee) { /* database logic */ }
}

class ReportGenerator {
    public void generateReport(Employee employee) { /* reporting logic */ }
}

class EmailService {
    public void sendEmail(Employee employee) { /* notification logic */ }
}
```

#### Benefits
- **Easier maintenance**: Changes are isolated
- **Better testability**: Smaller, focused units
- **Reduced coupling**: Dependencies are minimized
- **Improved readability**: Clear purpose for each class

#### Common Misconceptions
- **Myth**: SRP means "one method per class"
- **Reality**: It's about "one reason to change" - a class can have multiple methods if they serve the same responsibility
- **Myth**: SRP leads to too many small classes
- **Reality**: Proper grouping creates cohesive, meaningful classes

## 2. Open/Closed Principle (OCP) <a name="ocp"></a>

### Surface Level Knowledge
**"Software entities should be open for extension but closed for modification"** - you should be able to extend behavior without modifying existing code.

### Deep Understanding

#### Core Concept
OCP encourages designing systems where new functionality can be added by creating new code rather than changing existing, tested code. This is achieved through abstraction and polymorphism.

#### Implementation Strategies
1. **Strategy Pattern**: Encapsulate varying behavior
2. **Template Method**: Define skeleton with customizable steps
3. **Decorator Pattern**: Add functionality dynamically
4. **Observer Pattern**: Subscribe to changes

#### Code Examples

**Violation Example:**
```java
class AreaCalculator {
    public double calculateArea(Object shape) {
        if (shape instanceof Circle) {
            Circle circle = (Circle) shape;
            return Math.PI * circle.radius * circle.radius;
        } else if (shape instanceof Rectangle) {
            Rectangle rectangle = (Rectangle) shape;
            return rectangle.width * rectangle.height;
        }
        // Adding new shape requires modifying this method
        throw new IllegalArgumentException("Unknown shape");
    }
}
```

**OCP Compliant Solution:**
```java
interface Shape {
    double calculateArea();
}

class Circle implements Shape {
    private double radius;
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle implements Shape {
    private double width, height;
    public double calculateArea() {
        return width * height;
    }
}

class AreaCalculator {
    public double calculateArea(Shape shape) {
        return shape.calculateArea(); // Closed for modification
    }
}
// New shapes can be added without modifying existing code
```

#### Benefits
- **Stability**: Existing code remains unchanged
- **Scalability**: Easy to add new features
- **Testability**: Existing behavior is preserved
- **Reduced risk**: Less chance of introducing bugs in stable code

## 3. Liskov Substitution Principle (LSP) <a name="lsp"></a>

### Surface Level Knowledge
**"Subtypes must be substitutable for their base types"** - objects of a superclass should be replaceable with objects of its subclasses without breaking the application.

### Deep Understanding

#### Core Concept
LSP ensures that inheritance is used correctly. A subclass shouldn't strengthen preconditions, weaken postconditions, or change the invariants of the superclass.

#### Violation Indicators
- **Type checking**: `instanceof` checks in client code
- **NotImplementedException**: Throwing exceptions for inherited methods
- **Changed behavior**: Subclass behaves differently from expected superclass behavior

#### Code Examples

**Violation Example:**
```java
class Rectangle {
    protected int width, height;
    
    public void setWidth(int width) { this.width = width; }
    public void setHeight(int height) { this.height = height; }
    public int getArea() { return width * height; }
}

class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        super.setWidth(width);
        super.setHeight(width); // Violates LSP - changes behavior
    }
    
    @Override
    public void setHeight(int height) {
        super.setHeight(height);
        super.setWidth(height); // Violates LSP
    }
}

// Client code that breaks with Square
void testRectangle(Rectangle rectangle) {
    rectangle.setWidth(5);
    rectangle.setHeight(4);
    assert rectangle.getArea() == 20; // Fails for Square
}
```

**LSP Compliant Solution:**
```java
interface Shape {
    int getArea();
}

class Rectangle implements Shape {
    private int width, height;
    // constructor, getters, setters
    public int getArea() { return width * height; }
}

class Square implements Shape {
    private int side;
    // constructor, getter, setter
    public int getArea() { return side * side; }
}
```

#### Contract Rules
1. **Preconditions**: Subclass can't strengthen preconditions
2. **Postconditions**: Subclass can't weaken postconditions  
3. **Invariants**: Subclass must preserve superclass invariants
4. **History constraint**: Subclass can't modify state in ways superclass doesn't allow

## 4. Interface Segregation Principle (ISP) <a name="isp"></a>

### Surface Level Knowledge
**"Clients should not be forced to depend on interfaces they don't use"** - create specific interfaces rather than general-purpose ones.

### Deep Understanding

#### Core Concept
ISP promotes designing lean, focused interfaces. Large interfaces should be split into smaller, more specific ones so that clients only need to know about the methods that are of interest to them.

#### Code Examples

**Violation Example:**
```java
interface Worker {
    void work();
    void eat();
    void sleep();
    void code();
    void design();
    void test();
}

class Programmer implements Worker {
    public void work() { /* implementation */ }
    public void eat() { /* implementation */ }
    public void sleep() { /* implementation */ }
    public void code() { /* implementation */ }
    public void design() { /* empty - not needed */ }  // Violation
    public void test() { /* empty - not needed */ }    // Violation
}
```

**ISP Compliant Solution:**
```java
interface BasicHuman {
    void eat();
    void sleep();
}

interface Workable {
    void work();
}

interface ProgrammerTasks {
    void code();
}

interface DesignerTasks {
    void design();
}

interface TesterTasks {
    void test();
}

class Programmer implements BasicHuman, Workable, ProgrammerTasks {
    // Implement only relevant methods
    public void eat() { /* implementation */ }
    public void sleep() { /* implementation */ }
    public void work() { /* implementation */ }
    public void code() { /* implementation */ }
}
```

#### Benefits
- **Decoupling**: Reduced dependency between unrelated components
- **Flexibility**: Easier to implement and modify
- **Maintainability**: Changes affect only relevant clients
- **Testability**: Mocking becomes easier

## 5. Dependency Inversion Principle (DIP) <a name="dip"></a>

### Surface Level Knowledge
**"Depend on abstractions, not on concretions"** - high-level modules should not depend on low-level modules; both should depend on abstractions.

### Deep Understanding

#### Core Concept
DIP inverts the traditional dependency flow. Instead of high-level modules depending on low-level implementations, both depend on abstractions (interfaces or abstract classes).

#### Implementation Techniques
1. **Constructor Injection**: Dependencies provided via constructor
2. **Setter Injection**: Dependencies provided via setter methods  
3. **Interface Injection**: Dependencies provided via interface methods
4. **Dependency Injection Containers**: Frameworks that manage dependencies

#### Code Examples

**Violation Example:**
```java
class MySQLDatabase {  // Low-level module
    public void saveData(String data) {
        // MySQL specific implementation
    }
}

class DataProcessor {  // High-level module
    private MySQLDatabase database;  // Depends on concrete class
    
    public DataProcessor() {
        this.database = new MySQLDatabase();  // Tight coupling
    }
    
    public void processData(String data) {
        // processing logic
        database.saveData(data);
    }
}
```

**DIP Compliant Solution:**
```java
interface Database {  // Abstraction
    void saveData(String data);
}

class MySQLDatabase implements Database {  // Low-level module
    public void saveData(String data) {
        // MySQL specific implementation
    }
}

class PostgreSQLDatabase implements Database {
    public void saveData(String data) {
        // PostgreSQL specific implementation
    }
}

class DataProcessor {  // High-level module
    private Database database;  // Depends on abstraction
    
    public DataProcessor(Database database) {  // Dependency injection
        this.database = database;
    }
    
    public void processData(String data) {
        // processing logic
        database.saveData(data);
    }
}
```

#### Benefits
- **Flexibility**: Easy to swap implementations
- **Testability**: Easy to mock dependencies
- **Maintainability**: Changes are isolated
- **Reusability**: Components can be used in different contexts

## Comparative Analysis <a name="comparative-analysis"></a>

### When to Use Each Principle

| Principle | When to Use | Key Benefit | Common Patterns |
|-----------|-------------|-------------|-----------------|
| **SRP** | When class has multiple responsibilities | Easier maintenance | Service classes, Repository pattern |
| **OCP** | When expecting future extensions | Stability + extensibility | Strategy, Template Method |
| **LSP** | When using inheritance | Safe polymorphism | Composition over inheritance |
| **ISP** | When interfaces become too large | Reduced coupling | Role interfaces |
| **DIP** | When modules are tightly coupled | Testability + flexibility | Dependency Injection |

### Relationship Between Principles

```
SRP → Creates focused classes
     ↓
OCP → Makes classes extensible  
     ↓
LSP → Ensures safe inheritance
     ↓
ISP → Creates lean interfaces
     ↓
DIP → Manages dependencies
```

### Trade-offs and Considerations

| Principle | Trade-off | When to Be Cautious |
|-----------|-----------|---------------------|
| **SRP** | Many small classes | When it leads to anemic domains |
| **OCP** | Abstraction overhead | For simple, stable domains |
| **LSP** | Inheritance limitations | When favoring composition |
| **ISP** | Interface proliferation | For closely related functionalities |
| **DIP** | Complexity of DI | In simple applications |

## Interview Questions & Answers <a name="interview-qa"></a>

### Basic Level Questions

**Q1: What does SOLID stand for?**
**A:** SOLID is an acronym for:
- S: Single Responsibility Principle
- O: Open/Closed Principle  
- L: Liskov Substitution Principle
- I: Interface Segregation Principle
- D: Dependency Inversion Principle

**Q2: Why are SOLID principles important?**
**A:** They help create software that is:
- Maintainable: Easy to understand and modify
- Scalable: Easy to extend with new features
- Testable: Easy to write unit tests for
- Reusable: Components can be used in different contexts
- Robust: Fewer bugs and easier to debug

### Intermediate Level Questions

**Q3: Can you violate one SOLID principle while following others?**
**A:** Yes, it's possible. For example:
- You can follow SRP but violate DIP by depending on concrete classes
- You can follow OCP but violate LSP by creating non-substitutable subclasses
- The principles are complementary but independent

**Q4: How does SRP relate to cohesion and coupling?**
**A:** SRP increases cohesion (elements within a module belong together) and reduces coupling (dependencies between modules). A class with single responsibility has high cohesion, and by focusing on one concern, it has fewer reasons to depend on other classes.

### Advanced/Tricky Questions

**Q5: The Square-Rectangle problem is classic LSP violation. What's a less obvious LSP violation?**
**A:** **Example:** A `ReadOnlyCollection` extending `Collection`
```java
class ReadOnlyCollection extends Collection {
    @Override
    public void add(Object element) {
        throw new UnsupportedOperationException("Read-only");
    }
}
```
**Violation:** Client code expecting a `Collection` would be surprised that `add()` throws an exception. This strengthens preconditions (requires collection to be writable).

**Q6: Can OCP be taken too far? Provide an example.**
**A:** **Yes, over-engineering example:**
```java
// Unnecessary abstraction for simple requirement
interface NumberOperation {
    int execute(int a, int b);
}
class AddOperation implements NumberOperation { /* ... */ }
class SubtractOperation implements NumberOperation { /* ... */ }
// When simple methods would suffice: int add(int a, int b), int subtract(int a, int b)
```
**Reasoning:** If the operations are stable and unlikely to change, the abstraction adds complexity without benefit.

**Q7: How does DIP relate to Dependency Injection?**
**A:** **DIP** is the principle: "Depend on abstractions." **Dependency Injection** is the mechanism to achieve it by providing dependencies from outside. DI containers (Spring, Guice) implement DIP by managing object creation and dependency resolution.

**Q8: Is it possible to have too many interfaces with ISP?**
**A:** **Yes**, if interfaces are split unnecessarily:
```java
// Over-segregated interfaces
interface NameGetter { String getName(); }
interface AgeGetter { int getAge(); }
interface EmailGetter { String getEmail(); }
// Better: interface UserInfo { String getName(); int getAge(); String getEmail(); }
```
**Rule of thumb:** Group methods that are likely to change together or are used by the same clients.

### Scenario-Based Questions

**Q9: You're designing a payment system. How would SOLID principles guide your design?**
**A:** 
- **SRP:** Separate payment processing, validation, logging, notification
- **OCP:** Design payment interface to easily add new payment methods (Credit Card, PayPal, Crypto)
- **LSP:** Ensure all payment method implementations are substitutable
- **ISP:** Separate interfaces for payment processing, refunds, status checking
- **DIP:** High-level payment service should depend on payment abstractions, not concrete implementations

**Q10: Refactor this violating SRP and OCP:**
```java
class ReportGenerator {
    public void generateReport(String type) {
        if (type.equals("PDF")) {
            // Generate PDF
        } else if (type.equals("HTML")) {
            // Generate HTML
        }
        // Save to database
        // Send email
    }
}
```
**A:** 
```java
// SRP + OCP compliant
interface Report {
    void generate();
}

class PDFReport implements Report { /* ... */ }
class HTMLReport implements Report { /* ... */ }

class ReportService {  // SRP: Handles report generation workflow
    private Report report;
    private Repository repository;
    private NotificationService notification;
    
    public ReportService(Report report, Repository repo, NotificationService notif) {
        this.report = report;
        this.repository = repo;
        this.notification = notif;
    }
    
    public void generateAndSend() {
        report.generate();
        repository.save(report);
        notification.send(report);
    }
}
```

### Follow-up Questions

**Q11: How do SOLID principles relate to design patterns?**
**A:** Design patterns often embody SOLID principles:
- **Strategy Pattern:** OCP (open for new strategies), DIP (depends on strategy interface)
- **Decorator Pattern:** OCP (add functionality without modification), ISP (focused decorations)
- **Factory Pattern:** DIP (abstracts object creation), SRP (single creation responsibility)

**Q12: What's the most commonly violated SOLID principle and why?**
**A:** **SRP** is most commonly violated because:
- It's tempting to add "just one more method" to existing classes
- Time pressure leads to quick fixes in God classes
- The principle is often misunderstood as "one method per class"

**Q13: How do you balance SOLID principles with YAGNI (You Ain't Gonna Need It)?**
**A:** **Strategy:**
- Apply SRP and DIP from start (they rarely cause over-engineering)
- Apply OCP and ISP when change is likely or already requested
- Let violations emerge naturally, then refactor
- Focus on principles that provide immediate value

### Tricky Implementation Questions

**Q14: How would you handle a situation where following LSP seems impossible due to business rules?**
**A:** **Use composition over inheritance:**
```java
// Instead of forcing inheritance:
class Penguin extends Bird { // But penguins can't fly!
    @Override
    public void fly() { throw new UnsupportedOperationException(); } // LSP violation!

// Use composition:
class Bird {
    private FlyingAbility flyingAbility;  // Strategy pattern
    public void fly() { flyingAbility.fly(); }
}
class Penguin extends Bird {
    public Penguin() { this.flyingAbility = new NoFlying(); }
}
```

**Q15: When might violating ISP be acceptable?**
**A:** **When dealing with related functionalities that always change together:**
```java
interface CRUDOperations {  // Cohesive responsibilities
    void create();
    void read(); 
    void update();
    void delete();
}
// Splitting this might create artificial separation
```

This comprehensive guide covers SOLID principles from basic understanding to advanced implementation scenarios, preparing you for interviews and practical application in software design.
