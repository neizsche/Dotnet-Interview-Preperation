# Dependency Injection and Configuration - Complete Guide

## Table of Contents
1. [Service Lifetimes](#service-lifetimes)
2. [Service Registration Methods](#service-registration-methods)
3. [Constructor vs Property Injection](#constructor-vs-property-injection)
4. [Options Pattern](#options-pattern)
5. [Configuration Providers](#configuration-providers)
6. [Interview Questions](#interview-questions)

---

## Service Lifetimes

### Overview
Service lifetimes control how long service instances exist in the dependency injection container.

### Detailed Explanation

#### 1. Transient Lifetime
```csharp
services.AddTransient<IService, ServiceImplementation>();
```

**Behavior:**
- New instance created every time service is requested
- Each dependency gets a fresh copy
- Most resource-intensive lifetime

**When to Use:**
- Stateless services
- Services with lightweight initialization
- When each operation needs isolated state

```csharp
public class TransientService : ITransientService
{
    private readonly Guid _id = Guid.NewGuid();
    public Guid GetId() => _id;
}

// Each injection gets different ID
```

#### 2. Scoped Lifetime
```csharp
services.AddScoped<IService, ServiceImplementation>();
```

**Behavior:**
- Single instance per scope/request
- Shared within same HTTP request or scope
- Disposed at scope end

**When to Use:**
- Entity Framework DbContext
- Services needing request-specific data
- Unit of work patterns

```csharp
public class ScopedService : IScopedService
{
    private readonly Guid _id = Guid.NewGuid();
    public Guid GetId() => _id;
}

// Same ID within request, different across requests
```

#### 3. Singleton Lifetime
```csharp
services.AddSingleton<IService, ServiceImplementation>();
```

**Behavior:**
- Single instance for application lifetime
- Created on first request or at startup
- Must be thread-safe

**When to Use:**
- Configuration services
- Cache services
- Expensive-to-create objects

```csharp
public class SingletonService : ISingletonService
{
    private readonly Guid _id = Guid.NewGuid();
    public Guid GetId() => _id;
}

// Same ID throughout application lifetime
```

### Lifetime Comparison Table

| Aspect | Transient | Scoped | Singleton |
|--------|-----------|---------|-----------|
| Instance Creation | Every request | Per scope | Once |
| Memory Usage | Highest | Medium | Lowest |
| Thread Safety | Easy | Medium | Critical |
| Disposal | Immediate | Scope end | App shutdown |
| Use Case | Stateless services | Request-specific | Application-wide |

### Common Pitfalls

#### Captive Dependency Problem
```csharp
// WRONG: Singleton capturing transient
public class SingletonService
{
    private readonly ITransientService _transient;
    
    public SingletonService(ITransientService transient)
    {
        _transient = transient; // Transient becomes captive singleton!
    }
}
```

#### Scope Creation Issues
```csharp
// Creating scope manually - be careful with disposal
using (var scope = serviceProvider.CreateScope())
{
    var scopedService = scope.ServiceProvider.GetService<IScopedService>();
}
```

---

## Service Registration Methods

### Basic Registration Methods

#### 1. Interface-Implementation Registration
```csharp
services.AddTransient<IService, ServiceImplementation>();
services.AddScoped<IService, ServiceImplementation>();
services.AddSingleton<IService, ServiceImplementation>();
```

#### 2. Concrete Type Registration
```csharp
services.AddTransient<ServiceImplementation>();
// Injected directly without interface
```

#### 3. Instance Registration
```csharp
var instance = new ServiceImplementation();
services.AddSingleton<IService>(instance);
```

#### 4. Factory Pattern Registration
```csharp
services.AddTransient<IService>(provider => 
{
    var dependency = provider.GetService<IDependency>();
    return new ServiceImplementation(dependency);
});
```

### Advanced Registration Patterns

#### Conditional Registration
```csharp
services.AddTransient<IService>(provider =>
{
    var env = provider.GetService<IWebHostEnvironment>();
    return env.IsDevelopment() 
        ? new DevelopmentService() 
        : new ProductionService();
});
```

#### Multiple Implementations
```csharp
services.AddTransient<IService, ServiceA>();
services.AddTransient<IService, ServiceB>();

// Resolve all implementations
public class Consumer
{
    private readonly IEnumerable<IService> _services;
    
    public Consumer(IEnumerable<IService> services)
    {
        _services = services;
    }
}
```

#### Generic Registration
```csharp
services.AddTransient(typeof(IRepository<>), typeof(Repository<>));
```

### Factory Patterns in DI

#### 1. Simple Factory
```csharp
public interface IServiceFactory
{
    IService CreateService(string type);
}

services.AddTransient<IServiceFactory, ServiceFactory>();
```

#### 2. Delegate Factory
```csharp
public delegate IService ServiceFactory(string type);

services.AddTransient<ServiceA>();
services.AddTransient<ServiceB>();
services.AddTransient<ServiceFactory>(provider => type =>
{
    return type switch
    {
        "A" => provider.GetService<ServiceA>(),
        "B" => provider.GetService<ServiceB>(),
        _ => throw new ArgumentException($"Unknown service type: {type}")
    };
});
```

---

## Constructor vs Property Injection

### Constructor Injection
```csharp
public class OrderService
{
    private readonly IOrderRepository _repository;
    private readonly ILogger<OrderService> _logger;
    
    // Dependencies clearly visible
    public OrderService(IOrderRepository repository, ILogger<OrderService> logger)
    {
        _repository = repository ?? throw new ArgumentNullException(nameof(repository));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }
}
```

**Advantages:**
- Immutable dependencies
- Clear contract
- Compile-time safety
- Easy testing

### Property Injection
```csharp
public class OrderService
{
    // Dependencies can be set after construction
    [FromServices]
    public IOrderRepository Repository { get; set; }
    
    [FromServices]
    public ILogger<OrderService> Logger { get; set; }
}
```

**When to Use Property Injection:**
- Framework components (MVC filters, view components)
- Optional dependencies
- Legacy code integration

### Comparison Table

| Aspect | Constructor Injection | Property Injection |
|--------|----------------------|-------------------|
| Immutability | Yes | No |
| Compile-time Safety | High | Low |
| Testability | Excellent | Good |
| Framework Support | Default | Requires attributes |
| Circular Dependencies | Difficult | Possible |
| Optional Dependencies | Hard | Easy |

### Best Practices

#### Avoid Property Injection for Required Dependencies
```csharp
// GOOD - Constructor injection for required dependencies
public class Service
{
    private readonly IRequiredService _required;
    private IOptionalService _optional;
    
    public Service(IRequiredService required)
    {
        _required = required;
    }
    
    // Optional dependency via property
    public IOptionalService Optional
    {
        get => _optional ??= GetDefaultOptional();
        set => _optional = value;
    }
}
```

---

## Options Pattern

### Basic Usage

#### 1. Configuration Class
```csharp
public class ApiSettings
{
    public string BaseUrl { get; set; }
    public int TimeoutSeconds { get; set; }
    public int RetryCount { get; set; }
}
```

#### 2. Configuration Binding
```csharp
// appsettings.json
{
  "ApiSettings": {
    "BaseUrl": "https://api.example.com",
    "TimeoutSeconds": 30,
    "RetryCount": 3
  }
}

// Startup configuration
services.Configure<ApiSettings>(Configuration.GetSection("ApiSettings"));
```

#### 3. Usage in Services
```csharp
public class ApiClient
{
    private readonly ApiSettings _settings;
    
    public ApiClient(IOptions<ApiSettings> options)
    {
        _settings = options.Value; // Snapshot of settings
    }
}
```

### Advanced Options Patterns

#### IOptions vs IOptionsSnapshot vs IOptionsMonitor

| Interface | Lifetime | Change Detection | Use Case |
|-----------|----------|------------------|----------|
| IOptions<T> | Singleton | No | Static configuration |
| IOptionsSnapshot<T> | Scoped | Yes | Request-specific, reloaded each request |
| IOptionsMonitor<T> | Singleton | Yes | Global change notifications |

```csharp
// IOptionsSnapshot - reloaded per request
public class ScopedService
{
    private readonly ApiSettings _settings;
    
    public ScopedService(IOptionsSnapshot<ApiSettings> snapshot)
    {
        _settings = snapshot.Value; // Fresh config each request
    }
}

// IOptionsMonitor - listen for changes
public class SingletonService : IDisposable
{
    private readonly ApiSettings _settings;
    private readonly IDisposable _changeToken;
    
    public SingletonService(IOptionsMonitor<ApiSettings> monitor)
    {
        _settings = monitor.CurrentValue;
        _changeToken = monitor.OnChange(settings => 
        {
            _settings = settings; // React to configuration changes
        });
    }
    
    public void Dispose() => _changeToken?.Dispose();
}
```

#### Validation with Options
```csharp
public class ApiSettings : IValidatableObject
{
    [Required]
    [Url]
    public string BaseUrl { get; set; }
    
    [Range(1, 60)]
    public int TimeoutSeconds { get; set; }
    
    public IEnumerable<ValidationResult> Validate(ValidationContext context)
    {
        if (TimeoutSeconds > 30 && RetryCount > 5)
        {
            yield return new ValidationResult("Timeout too long for many retries");
        }
    }
}

// Enable validation
services.AddOptions<ApiSettings>()
    .Bind(Configuration.GetSection("ApiSettings"))
    .ValidateDataAnnotations()
    .ValidateOnStart(); // Validate at startup
```

---

## Configuration Providers

### Built-in Providers

#### 1. JSON Configuration
```csharp
// Default appsettings.json
var builder = WebApplication.CreateBuilder(args);

// Additional JSON files
builder.Configuration.AddJsonFile("appsettings.Development.json", optional: true);
builder.Configuration.AddJsonFile($"appsettings.{env.EnvironmentName}.json", optional: true);
```

#### 2. Environment Variables
```csharp
// Environment variables override JSON
// MYAPP_APISETTINGS__BASEURL=https://override.com
```

#### 3. Command Line
```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Configuration.AddCommandLine(args);
```

#### 4. User Secrets (Development)
```csharp
builder.Configuration.AddUserSecrets<Program>();
```

### Custom Configuration Providers

#### Creating Custom Provider
```csharp
public class DatabaseConfigurationProvider : ConfigurationProvider
{
    private readonly string _connectionString;
    
    public DatabaseConfigurationProvider(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    public override void Load()
    {
        using var connection = new SqlConnection(_connectionString);
        var settings = connection.Query<KeyValuePair<string, string>>(
            "SELECT Key, Value FROM Settings");
        
        Data = settings.ToDictionary(x => x.Key, x => x.Value);
    }
}

public class DatabaseConfigurationSource : IConfigurationSource
{
    private readonly string _connectionString;
    
    public DatabaseConfigurationSource(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    public IConfigurationProvider Build(IConfigurationBuilder builder)
    {
        return new DatabaseConfigurationProvider(_connectionString);
    }
}

// Extension method
public static class DatabaseConfigurationExtensions
{
    public static IConfigurationBuilder AddDatabaseConfiguration(
        this IConfigurationBuilder builder, 
        string connectionString)
    {
        return builder.Add(new DatabaseConfigurationSource(connectionString));
    }
}

// Usage
builder.Configuration.AddDatabaseConfiguration("Server=...");
```

### Configuration Precedence

The last provider added has the highest precedence:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Configuration
    .AddJsonFile("appsettings.json")                    // Lowest priority
    .AddJsonFile($"appsettings.{env.EnvironmentName}.json", optional: true)
    .AddEnvironmentVariables()                         // Medium priority  
    .AddCommandLine(args)                              // Highest priority
    .AddUserSecrets<Program>();                        // Development only
```

---

## Interview Questions & Answers

### Service Lifetimes Questions

#### Q1: What happens when a Singleton service depends on a Transient service?
**Answer:** The Transient service becomes effectively a Singleton because it's only instantiated once when the Singleton is created. This is called the "captive dependency" problem.

```csharp
// Problematic setup
services.AddSingleton<ISingletonService, SingletonService>();
services.AddTransient<ITransientService, TransientService>();

public class SingletonService
{
    private readonly ITransientService _transient;
    public SingletonService(ITransientService transient) => _transient = transient;
}
// _transient will never change - it's captive!
```

#### Q2: How to resolve Scoped service in Singleton?
**Answer:** Use IServiceScopeFactory to create a scope when needed:

```csharp
public class SingletonService
{
    private readonly IServiceScopeFactory _scopeFactory;
    
    public SingletonService(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }
    
    public void ProcessRequest()
    {
        using var scope = _scopeFactory.CreateScope();
        var scopedService = scope.ServiceProvider.GetService<IScopedService>();
        // Use scopedService
    }
}
```

#### Q3: What's the difference between AddSingleton<TService>() and AddSingleton<TService>(instance)?
**Answer:** 
- `AddSingleton<TService>()` lets the container manage the lifecycle
- `AddSingleton<TService>(instance)` registers an existing instance that won't be disposed by the container

### Service Registration Questions

#### Q4: How to register multiple implementations and resolve specific one?
**Answer:** Use factory pattern or named registrations:

```csharp
// Registration
services.AddTransient<ServiceA>();
services.AddTransient<ServiceB>();
services.AddTransient<ServiceFactory>();

// Factory implementation
public class ServiceFactory
{
    private readonly IServiceProvider _provider;
    
    public ServiceFactory(IServiceProvider provider) => _provider = provider;
    
    public IService GetService(string type) => type switch
    {
        "A" => _provider.GetService<ServiceA>(),
        "B" => _provider.GetService<ServiceB>(),
        _ => throw new ArgumentException($"Unknown type: {type}")
    };
}
```

#### Q5: What's the difference between TryAdd and Add methods?
**Answer:** 
- `Add` always adds the registration
- `TryAdd` only adds if no implementation exists for the service type

```csharp
services.AddTransient<IService, ServiceA>();
services.TryAddTransient<IService, ServiceB>(); // This won't register

// ServiceB won't be registered because ServiceA already exists
```

### Constructor Injection Questions

#### Q6: How to handle optional dependencies with constructor injection?
**Answer:** Use default parameters or multiple constructors:

```csharp
// Using default parameters
public class Service
{
    private readonly IOptionalService _optional;
    
    public Service(IRequiredService required, 
                  IOptionalService optional = null)
    {
        _optional = optional ?? new DefaultOptionalService();
    }
}

// Using multiple constructors
public class Service
{
    private readonly IOptionalService _optional;
    
    public Service(IRequiredService required) 
        : this(required, new DefaultOptionalService()) { }
    
    public Service(IRequiredService required, IOptionalService optional)
    {
        _optional = optional;
    }
}
```

### Options Pattern Questions

#### Q7: When to use IOptionsSnapshot vs IOptionsMonitor?
**Answer:** 
- Use `IOptionsSnapshot<T>` in scoped services when you need fresh configuration each request
- Use `IOptionsMonitor<T>` in singleton services to react to configuration changes

```csharp
// Scoped service - fresh config each request
public class ScopedService
{
    public ScopedService(IOptionsSnapshot<Config> snapshot)
    {
        var config = snapshot.Value; // Reloaded each request
    }
}

// Singleton service - listen for changes
public class SingletonService : IDisposable
{
    private readonly IDisposable _changeToken;
    
    public SingletonService(IOptionsMonitor<Config> monitor)
    {
        _changeToken = monitor.OnChange(config => 
        {
            // React to configuration changes
        });
    }
}
```

#### Q8: How to validate options at startup?
**Answer:** Use `ValidateOnStart()`:

```csharp
services.AddOptions<ApiSettings>()
    .Bind(Configuration.GetSection("ApiSettings"))
    .ValidateDataAnnotations()
    .Validate(settings => 
    {
        if (string.IsNullOrEmpty(settings.BaseUrl))
            return false;
        return true;
    })
    .ValidateOnStart(); // Validates when host starts
```

### Configuration Providers Questions

#### Q9: What's the configuration precedence order?
**Answer:** Last provider wins. Typical order:
1. appsettings.json (lowest)
2. appsettings.{Environment}.json
3. User Secrets (Development)
4. Environment Variables
5. Command Line Arguments (highest)

#### Q10: How to create a custom configuration provider that reloads?
**Answer:** Implement `IConfigurationSource` and `ConfigurationProvider` with change detection:

```csharp
public class ReloadableDatabaseConfigurationProvider : ConfigurationProvider, IDisposable
{
    private readonly Timer _timer;
    
    public ReloadableDatabaseConfigurationProvider()
    {
        _timer = new Timer(Reload, null, TimeSpan.Zero, TimeSpan.FromMinutes(5));
    }
    
    private void Reload(object state) => Load();
    
    public void Dispose() => _timer?.Dispose();
}
```

### Tricky Scenarios

#### Q11: Circular dependency resolution
**Answer:** Redesign to avoid circular dependencies or use property injection:

```csharp
// Problem: ServiceA → ServiceB → ServiceA
// Solution: Extract common functionality or use interfaces

public interface ICommonFunctionality { }
public class CommonService : ICommonFunctionality { }

public class ServiceA
{
    public ServiceA(ServiceB b, ICommonFunctionality common) { }
}

public class ServiceB  
{
    public ServiceB(ICommonFunctionality common) { }
}
```

#### Q12: Disposing of services properly
**Answer:** The container automatically disposes `IDisposable` services it creates:

```csharp
// Transient and Scoped IDisposable services are disposed automatically
// Singleton IDisposable services are disposed when the container is disposed

// Manual disposal may be needed for factory-created services
using (var service = factory.CreateService())
{
    // use service
}
```

#### Q13: Service locator anti-pattern vs proper DI
**Answer:** Avoid service locator pattern when possible:

```csharp
// ANTI-PATTERN: Service locator
public class BadService
{
    private readonly IServiceProvider _provider;
    
    public void DoWork()
    {
        var dependency = _provider.GetService<IDependency>(); // Hides dependencies
    }
}

// PROPER: Constructor injection
public class GoodService
{
    private readonly IDependency _dependency;
    
    public GoodService(IDependency dependency) // Clear dependencies
    {
        _dependency = dependency;
    }
}
```

This comprehensive guide covers all aspects of Dependency Injection and Configuration in .NET with practical examples and interview preparation materials.
