# Asynchronous Programming Deep Dive

## Table of Contents
1. [Async/Await Patterns and Best Practices](#asyncawait-patterns-and-best-practices)
2. [Task Parallel Library (TPL) and Dataflow](#task-parallel-library-tpl-and-dataflow)
3. [ConfigureAwait Best Practices](#configureawait-best-practices)
4. [Async Streams (IAsyncEnumerable) and Cancellation](#async-streams-iasyncenumerable-and-cancellation)
5. [Comparison Tables](#comparison-tables)
6. [Probable Questions and Answers](#probable-questions-and-answers)

---

## Async/Await Patterns and Best Practices

### Surface Level Knowledge
Async/await simplifies writing asynchronous code by making it look synchronous while maintaining non-blocking execution.

### Deep Understanding

#### How Async/Await Works
```csharp
public async Task<int> GetDataAsync()
{
    // State machine generated by compiler
    var data = await DownloadDataAsync();
    return ProcessData(data);
}
```

**Compiler Transformation:**
- Creates a state machine that tracks execution progress
- `await` points become state transitions
- Exception handling is preserved across await boundaries

#### Best Practices

**1. Async All the Way**
```csharp
// ✅ Good - async all the way
public async Task ProcessDataAsync()
{
    var data = await GetDataAsync();
    await ProcessAsync(data);
}

// ❌ Bad - mixed sync/async
public void ProcessData()
{
    var data = GetDataAsync().Result; // Deadlock risk!
    ProcessAsync(data).Wait();
}
```

**2. Avoid async void**
```csharp
// ✅ Good - returns Task
public async Task ProcessAsync() { }

// ❌ Bad - async void (only for event handlers)
public async void ProcessAsync() { } // Exceptions can't be caught normally
```

**3. ConfigureAwait(false) for Library Code**
```csharp
public async Task<string> GetDataAsync()
{
    var data = await DownloadAsync().ConfigureAwait(false);
    return Process(data); // Doesn't need original context
}
```

**4. Exception Handling**
```csharp
public async Task ProcessWithRetryAsync()
{
    for (int i = 0; i < 3; i++)
    {
        try
        {
            await ProcessAsync();
            return;
        }
        catch (HttpRequestException) when (i < 2)
        {
            await Task.Delay(1000);
        }
    }
}
```

#### Advanced Patterns

**1. WhenAll for Parallel Execution**
```csharp
public async Task<(Data data, Metadata metadata)> LoadAllAsync()
{
    var dataTask = GetDataAsync();
    var metadataTask = GetMetadataAsync();
    
    await Task.WhenAll(dataTask, metadataTask);
    
    return (dataTask.Result, metadataTask.Result);
}
```

**2. WhenAny for First Completion**
```csharp
public async Task<string> GetFirstResponseAsync()
{
    var tasks = new List<Task<string>> {
        Source1Async(),
        Source2Async(),
        Source3Async()
    };
    
    var completedTask = await Task.WhenAny(tasks);
    return await completedTask;
}
```

**3. Cancellation Support**
```csharp
public async Task ProcessWithCancellationAsync(CancellationToken cancellationToken = default)
{
    await Task.Delay(1000, cancellationToken);
    cancellationToken.ThrowIfCancellationRequested();
    
    // Or use with timeout
    using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
    await LongRunningOperationAsync(cts.Token);
}
```

---

## Task Parallel Library (TPL) and Dataflow

### Surface Level Knowledge
TPL provides higher-level abstractions for parallel and concurrent programming, while Dataflow offers actor-based message passing.

### Deep Understanding

#### TPL Core Components

**1. Task Parallelism**
```csharp
// Parallel.Invoke for independent operations
Parallel.Invoke(
    () => ProcessImage("image1.jpg"),
    () => ProcessImage("image2.jpg"),
    () => ProcessImage("image3.jpg")
);

// Parallel.For for data parallelism
Parallel.For(0, 100, i =>
{
    ProcessItem(i);
});
```

**2. PLINQ (Parallel LINQ)**
```csharp
var results = data.AsParallel()
    .Where(x => x.IsValid)
    .WithDegreeOfParallelism(4)
    .WithCancellation(cancellationToken)
    .Select(x => Process(x))
    .ToList();
```

#### TPL Dataflow

**1. Basic Dataflow Blocks**
```csharp
var bufferBlock = new BufferBlock<int>();
var actionBlock = new ActionBlock<int>(async x =>
{
    await ProcessAsync(x);
}, new ExecutionDataflowBlockOptions
{
    MaxDegreeOfParallelism = 4,
    BoundedCapacity = 10
});

// Link blocks
bufferBlock.LinkTo(actionBlock, new DataflowLinkOptions { PropagateCompletion = true });
```

**2. Complex Pipeline**
```csharp
public async Task ProcessDataFlowAsync(IEnumerable<Data> data)
{
    var downloadBlock = new TransformBlock<Data, ProcessedData>(
        async d => await DownloadAsync(d),
        new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = 3 });
    
    var processBlock = new TransformBlock<ProcessedData, Result>(
        d => Process(d),
        new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = 2 });
    
    var batchBlock = new BatchBlock<Result>(10);
    var saveBlock = new ActionBlock<Result[]>(async results => 
        await SaveBatchAsync(results));
    
    // Create pipeline
    downloadBlock.LinkTo(processBlock);
    processBlock.LinkTo(batchBlock);
    batchBlock.LinkTo(saveBlock);
    
    // Feed data
    foreach (var item in data)
    {
        await downloadBlock.SendAsync(item);
    }
    
    downloadBlock.Complete();
    await saveBlock.Completion;
}
```

**3. Error Handling in Dataflow**
```csharp
var options = new ExecutionDataflowBlockOptions
{
    BoundedCapacity = 10,
    MaxDegreeOfParallelism = 4
};

var processingBlock = new ActionBlock<Data>(async data =>
{
    try
    {
        await ProcessAsync(data);
    }
    catch (Exception ex)
    {
        // Handle error without breaking the pipeline
        await LogErrorAsync(ex);
    }
}, options);
```

#### Advanced TPL Patterns

**1. Producer-Consumer with TPL Dataflow**
```csharp
public class AsyncProducerConsumer<T>
{
    private readonly BufferBlock<T> _buffer = new BufferBlock<T>();
    
    public async Task ProduceAsync(T item)
    {
        await _buffer.SendAsync(item);
    }
    
    public async Task<T> ConsumeAsync()
    {
        return await _buffer.ReceiveAsync();
    }
}
```

**2. Throttling with SemaphoreSlim**
```csharp
public class ThrottledProcessor
{
    private readonly SemaphoreSlim _semaphore;
    
    public ThrottledProcessor(int maxConcurrency)
    {
        _semaphore = new SemaphoreSlim(maxConcurrency);
    }
    
    public async Task ProcessAsync(Func<Task> operation)
    {
        await _semaphore.WaitAsync();
        try
        {
            await operation();
        }
        finally
        {
            _semaphore.Release();
        }
    }
}
```

---

## ConfigureAwait Best Practices

### Surface Level Knowledge
`ConfigureAwait(false)` prevents deadlocks by not capturing the synchronization context.

### Deep Understanding

#### Synchronization Context
```csharp
// UI Context (Windows Forms, WPF)
async void Button_Click(object sender, EventArgs e)
{
    // This await captures UI context
    var data = await GetDataAsync();
    textBox.Text = data; // Back on UI thread automatically
}

// Library code - no UI context needed
public async Task<string> ProcessDataAsync()
{
    var rawData = await DownloadAsync().ConfigureAwait(false);
    // Continues on thread pool thread
    return Process(rawData);
}
```

#### When to Use ConfigureAwait(false)

**✅ Use in Library Code:**
```csharp
public class DataProcessor
{
    public async Task ProcessAsync()
    {
        // No UI dependencies - use ConfigureAwait(false)
        var data = await DownloadAsync().ConfigureAwait(false);
        var result = await TransformAsync(data).ConfigureAwait(false);
        await SaveAsync(result).ConfigureAwait(false);
    }
}
```

**❌ Don't Use in UI Code:**
```csharp
public partial class MainForm : Form
{
    private async void LoadDataButton_Click(object sender, EventArgs e)
    {
        // ❌ Wrong - will throw exception when updating UI
        var data = await GetDataAsync().ConfigureAwait(false);
        dataLabel.Text = data; // Invalid cross-thread operation!
        
        // ✅ Correct
        var data = await GetDataAsync();
        dataLabel.Text = data; // Properly on UI thread
    }
}
```

#### Advanced Scenarios

**1. Mixed Context Scenarios**
```csharp
public async Task<string> ComplexOperationAsync()
{
    // Start on calling context (could be UI)
    var initialData = await GetInitialDataAsync();
    
    // CPU-intensive work - switch to thread pool
    var processed = await Task.Run(() => ProcessCpuIntensive(initialData))
        .ConfigureAwait(false);
    
    // More async work continues on thread pool
    var finalResult = await TransformAsync(processed).ConfigureAwait(false);
    
    // Need to return to original context?
    // Caller decides based on their context
    return finalResult;
}
```

**2. Deadlock Prevention**
```csharp
// ❌ Deadlock-prone code
public string GetData()
{
    return GetDataAsync().Result; // Blocks waiting for async completion
}

public async Task<string> GetDataAsync()
{
    await Task.Delay(1000);
    // If called from UI thread, deadlock occurs here
    return "Data";
}

// ✅ Safe version with ConfigureAwait(false)
public async Task<string> GetDataAsync()
{
    await Task.Delay(1000).ConfigureAwait(false);
    return "Data"; // No context captured, no deadlock
}
```

---

## Async Streams (IAsyncEnumerable) and Cancellation

### Surface Level Knowledge
`IAsyncEnumerable<T>` allows asynchronous iteration over sequences, supporting cancellation and backpressure.

### Deep Understanding

#### Basic Async Streams
```csharp
public async IAsyncEnumerable<Data> GetDataStreamAsync()
{
    for (int i = 0; i < 10; i++)
    {
        // Simulate async work to get each item
        var data = await FetchDataAsync(i);
        yield return data;
    }
}

// Consumption
await foreach (var data in GetDataStreamAsync())
{
    Process(data);
}
```

#### Cancellation Support
```csharp
public async IAsyncEnumerable<Data> GetDataStreamAsync(
    [EnumeratorCancellation] CancellationToken cancellationToken = default)
{
    var page = 0;
    while (true)
    {
        cancellationToken.ThrowIfCancellationRequested();
        
        var batch = await GetBatchAsync(page++, cancellationToken);
        if (batch.Count == 0) yield break;
        
        foreach (var item in batch)
        {
            yield return item;
        }
    }
}

// Usage with cancellation
using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
await foreach (var item in GetDataStreamAsync().WithCancellation(cts.Token))
{
    Process(item);
}
```

#### Advanced Patterns

**1. Backpressure with Channel**
```csharp
public static async IAsyncEnumerable<T> CreateBufferedStreamAsync<T>(
    IAsyncEnumerable<T> source, int bufferCapacity)
{
    var channel = Channel.CreateBounded<T>(bufferCapacity);
    var writer = channel.Writer;
    
    // Producer task
    _ = Task.Run(async () =>
    {
        await foreach (var item in source)
        {
            await writer.WriteAsync(item);
        }
        writer.Complete();
    });
    
    // Consumer enumeration
    await foreach (var item in channel.Reader.ReadAllAsync())
    {
        yield return item;
    }
}
```

**2. Combining Multiple Async Streams**
```csharp
public static async IAsyncEnumerable<T> MergeAsync<T>(
    params IAsyncEnumerable<T>[] streams)
{
    var channel = Channel.CreateUnbounded<T>();
    var writer = channel.Writer;
    
    var tasks = streams.Select(async stream =>
    {
        await foreach (var item in stream)
        {
            await writer.WriteAsync(item);
        }
    }).ToArray();
    
    // Close channel when all streams complete
    _ = Task.WhenAll(tasks).ContinueWith(_ => writer.Complete());
    
    await foreach (var item in channel.Reader.ReadAllAsync())
    {
        yield return item;
    }
}
```

**3. Error Handling in Async Streams**
```csharp
public static async IAsyncEnumerable<Result<T>> WithErrorHandling<T>(
    IAsyncEnumerable<T> source)
{
    await foreach (var item in source)
    {
        Result<T> result;
        try
        {
            result = Result<T>.Success(item);
        }
        catch (Exception ex)
        {
            result = Result<T>.Failure(ex);
        }
        yield return result;
    }
}
```

#### Cancellation Token Best Practices

**1. Proper Token Propagation**
```csharp
public async Task ProcessWithCancellationAsync(CancellationToken cancellationToken = default)
{
    // ✅ Proper token propagation
    await Operation1Async(cancellationToken);
    await Operation2Async(cancellationToken);
    
    // ❌ Don't create new tokens without linking
    // await Operation3Async(new CancellationToken()); // Wrong!
}

public async Task<string> DownloadWithTimeoutAsync(
    string url, TimeSpan timeout, CancellationToken externalToken = default)
{
    using var timeoutCts = new CancellationTokenSource(timeout);
    using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
        externalToken, timeoutCts.Token);
    
    return await DownloadAsync(url, linkedCts.Token);
}
```

**2. Cooperative Cancellation**
```csharp
public async Task LongRunningOperationAsync(CancellationToken cancellationToken = default)
{
    for (int i = 0; i < 100; i++)
    {
        cancellationToken.ThrowIfCancellationRequested();
        
        // Do work in chunks
        await ProcessChunkAsync(i);
        
        // Or check periodically for long operations
        if (i % 10 == 0)
        {
            cancellationToken.ThrowIfCancellationRequested();
        }
    }
}
```

---

## Comparison Tables

### Async Patterns Comparison

| Pattern | Use Case | Pros | Cons | When to Use |
|---------|----------|------|------|-------------|
| **async/await** | General async operations | Simple, readable, exception handling | Overhead for very short operations | Most async scenarios |
| **Task.Run** | CPU-bound work | Offload to thread pool | Context switching overhead | CPU-intensive operations |
| **Parallel.For/ForEach** | Data parallelism | Optimized for CPU-bound work | Not for I/O operations | Large data processing |
| **TPL Dataflow** | Pipeline processing | Fine-grained control, backpressure | Complexity for simple cases | Complex data processing pipelines |
| **IAsyncEnumerable** | Async sequences | Memory efficient, cancellation | More complex than lists | Streaming large datasets |

### ConfigureAwait Usage Guide

| Scenario | ConfigureAwait | Reason |
|----------|----------------|---------|
| **UI Event Handlers** | `false` ❌ | Need to return to UI context |
| **Library Code** | `false` ✅ | No UI dependencies |
| **ASP.NET Core Controllers** | `false` ✅ | No synchronization context |
| **WinForms/WPF UI Code** | `false` ❌ | Need UI context for updates |
| **Generic Business Logic** | `false` ✅ | Usually no context requirements |

### Cancellation Pattern Comparison

| Pattern | Use Case | Complexity | Performance |
|---------|----------|------------|-------------|
| **Timeout** | Simple time limits | Low | Good |
| **Linked Tokens** | Multiple cancellation sources | Medium | Very Good |
| **Cooperative Cancellation** | Long-running operations | Medium | Excellent |
| **CancellationTokenSource** | Manual cancellation control | Low | Good |

---

## Probable Questions and Answers

### Basic Level Questions

**Q1: What's the difference between `Task.Wait()` and `await task`?**

**Answer:**
- `Task.Wait()` is **blocking** - it synchronously waits for completion
- `await task` is **non-blocking** - it returns control to the caller

```csharp
// ❌ Blocks thread, can cause deadlocks
public string GetData()
{
    return GetDataAsync().Result;
}

// ✅ Non-blocking, proper async
public async Task<string> GetDataAsync()
{
    return await GetDataAsync();
}
```

**Reasoning:** `Wait()`/`Result` can cause deadlocks in UI or ASP.NET contexts because they block while waiting for async operations that need the same context to complete.

**Q2: When should you use `async void`?**

**Answer:** Only for event handlers. Avoid in all other cases.

```csharp
// ✅ Acceptable - event handler
private async void Button_Click(object sender, EventArgs e)
{
    await LoadDataAsync();
}

// ❌ Dangerous - exceptions can crash application
public async void ProcessData()
{
    await SomeOperationAsync(); // Exception not catchable normally
}
```

**Reasoning:** `async void` methods don't allow callers to await completion or properly handle exceptions.

### Intermediate Level Questions

**Q3: How does `ConfigureAwait(false)` prevent deadlocks?**

**Answer:** It avoids capturing the synchronization context, allowing continuation on any thread pool thread.

```csharp
public async Task<string> DeadlockProneMethod()
{
    // Captures context (UI/ASP.NET)
    var data = await GetDataAsync();
    return data; // Needs original context to continue
}

public void Caller()
{
    // UI thread calls this
    var result = DeadlockProneMethod().Result; // Deadlock!
}

public async Task<string> SafeMethod()
{
    // No context captured
    var data = await GetDataAsync().ConfigureAwait(false);
    return data; // Can continue on any thread
}
```

**Reasoning:** The deadlock occurs because the UI thread is blocked waiting for the async method, but the async method needs the UI thread to complete.

**Q4: What's the difference between `Task.WhenAll` and `Task.WhenAny`?**

**Answer:**
- `Task.WhenAll` waits for **all** tasks to complete
- `Task.WhenAny` waits for **any** task to complete

```csharp
// WhenAll - all must complete
var tasks = new List<Task> { Task1(), Task2(), Task3() };
await Task.WhenAll(tasks); // Waits for all three

// WhenAny - first completion wins
var completed = await Task.WhenAny(tasks);
var result = await completed; // Get result of first completed
```

**Reasoning:** `WhenAll` is for parallel processing where all results are needed. `WhenAny` is useful for redundancy or timeout scenarios.

### Advanced Level Questions

**Q5: How do async streams handle backpressure?**

**Answer:** Through synchronous consumption - the producer waits for the consumer to request the next item.

```csharp
public async IAsyncEnumerable<int> GenerateNumbersAsync()
{
    for (int i = 0; i < 1000; i++)
    {
        await Task.Delay(100); // Simulate async work
        yield return i; // Waits here until consumer reads the value
    }
}

// Consumer controls pace
await foreach (var number in GenerateNumbersAsync())
{
    await ProcessAsync(number); // Producer waits for this to complete
}
```

**Reasoning:** Each `yield return` acts as a checkpoint where the producer waits for the consumer to process the current item before producing the next.

**Q6: What's the difference between `CancellationTokenSource.Cancel()` and `CancellationToken.ThrowIfCancellationRequested()`?**

**Answer:**
- `Cancel()` **signals** cancellation from the source side
- `ThrowIfCancellationRequested()` **checks** and throws from the operation side

```csharp
public async Task LongOperationAsync(CancellationToken cancellationToken)
{
    while (true)
    {
        cancellationToken.ThrowIfCancellationRequested(); // Check point
        await DoWorkAsync();
    }
}

// Usage
var cts = new CancellationTokenSource();
var task = LongOperationAsync(cts.Token);

// Later...
cts.Cancel(); // Signals cancellation
await task; // Will throw OperationCanceledException
```

**Reasoning:** `Cancel()` initiates cancellation, while `ThrowIfCancellationRequested()` is how operations respond to cancellation requests.

### Tricky Questions

**Q7: Why might an async method never complete?**

**Answer:** Common causes include:
1. **Deadlocks** from mixing `await` with `.Result`/`.Wait()`
2. **Unobserved exceptions** in fire-and-forget tasks
3. **Cancellation tokens** not being propagated
4. **Infinite loops** without cancellation checks

```csharp
// ❌ Deadlock scenario
public string GetData()
{
    return GetDataAsync().Result; // UI thread deadlock
}

public async Task<string> GetDataAsync()
{
    await Task.Delay(1000);
    return "Data"; // Needs UI context to continue
}
```

**Reasoning:** Understanding common pitfalls helps debug hanging async operations.

**Q8: What's the performance impact of async/await?**

**Answer:** There's overhead from state machine generation, but benefits usually outweigh costs:

```csharp
// Overhead: state machine allocation, context switching
// Benefits: scalability, responsiveness

public async Task LightweightAsync()
{
    // Might be faster synchronous
    await Task.CompletedTask;
}

public async Task BeneficialAsync()
{
    // Clear benefit - I/O operation
    await httpClient.GetAsync("...");
}
```

**Reasoning:** Async has overhead but provides scalability by freeing threads during I/O operations.

### Follow-up Questions

**Q9: How would you implement a async-compatible producer-consumer pattern?**

**Answer:** Using `Channel<T>` or `BufferBlock<T>`:

```csharp
public class AsyncProducerConsumer<T>
{
    private readonly Channel<T> _channel = Channel.CreateUnbounded<T>();
    
    public async Task ProduceAsync(T item)
    {
        await _channel.Writer.WriteAsync(item);
    }
    
    public async IAsyncEnumerable<T> ConsumeAsync()
    {
        await foreach (var item in _channel.Reader.ReadAllAsync())
        {
            yield return item;
        }
    }
}
```

**Reasoning:** Channels provide a modern, efficient way to implement async producer-consumer patterns.

**Q10: When should you use TPL Dataflow over simple async/await?**

**Answer:** When you need complex processing pipelines with backpressure, parallelism control, and message passing:

```csharp
// Simple case - async/await is sufficient
public async Task ProcessSimpleAsync()
{
    var data = await LoadAsync();
    var transformed = await TransformAsync(data);
    await SaveAsync(transformed);
}

// Complex case - TPL Dataflow is better
public async Task ProcessComplexPipelineAsync()
{
    var loadBlock = new TransformBlock<Input, Data>(...);
    var processBlock = new TransformBlock<Data, Result>(...);
    var saveBlock = new ActionBlock<Result>(...);
    
    // Complex linking with filtering, parallelism control
}
```

**Reasoning:** Dataflow excels at complex data processing pipelines but adds complexity for simple scenarios.

This comprehensive guide covers async programming from basic concepts to advanced patterns, providing both surface-level understanding and deep technical knowledge. The questions and answers address common pitfalls and tricky scenarios you'll encounter in real-world applications.
