# Microservices Architecture - Comprehensive Guide for .NET Developers

## Table of Contents
1. [Service Decomposition and Bounded Contexts](#service-decomposition)
2. [Inter-service Communication](#inter-service-communication)
3. [Distributed Transactions and Saga Pattern](#distributed-transactions)
4. [API Gateway and Service Discovery](#api-gateway)
5. [Circuit Breaker and Retry Patterns](#circuit-breaker)
6. [Domain-Driven Design (DDD)](#ddd)
7. [Cloud-Native Development](#cloud-native)
8. [Interview Questions and Answers](#interview-questions)

---

## 1. Service Decomposition and Bounded Contexts {#service-decomposition}

### What is Service Decomposition?
Service decomposition is the process of breaking down a monolithic application into smaller, independent services based on business capabilities.

### Bounded Contexts in DDD
A Bounded Context is a central pattern in Domain-Driven Design that defines the boundaries within which a particular domain model applies.

```csharp
// Example: E-commerce domain bounded contexts
public class OrderContext
{
    // Order-related entities and logic
    public class Order { /* ... */ }
    public class OrderItem { /* ... */ }
}

public class InventoryContext
{
    // Inventory-related entities and logic
    public class Product { /* ... */ }
    public class Stock { /* ... */ }
}

public class ShippingContext
{
    // Shipping-related entities and logic
    public class Shipment { /* ... */ }
    public class Delivery { /* ... */ }
}
```

### When to Use Different Decomposition Strategies

| Strategy | When to Use | Pros | Cons |
|----------|-------------|------|------|
| **Business Capability** | Clear business domains exist | Aligns with organization structure | May create chatty services |
| **Domain-Driven Design** | Complex business logic | Excellent for complex domains | Steep learning curve |
| **Decomposition by Subdomain** | Large, complex domains | Gradual decomposition | Requires domain expertise |
| **Strangler Pattern** | Migrating from monolith | Low risk, incremental | Temporary complexity |

---

## 2. Inter-service Communication {#inter-service-communication}

### Synchronous Communication (gRPC)

**gRPC in .NET:**
```csharp
// Protobuf definition (order.proto)
service OrderService {
    rpc CreateOrder(CreateOrderRequest) returns (OrderResponse);
}

message CreateOrderRequest {
    string user_id = 1;
    repeated OrderItem items = 2;
}

// .NET Implementation
public class OrderService : OrderService.OrderServiceBase
{
    public override async Task<OrderResponse> CreateOrder(
        CreateOrderRequest request, ServerCallContext context)
    {
        // Process order logic
        return new OrderResponse { OrderId = Guid.NewGuid().ToString() };
    }
}

// Client implementation
var channel = GrpcChannel.ForAddress("https://localhost:5001");
var client = new OrderService.OrderServiceClient(channel);
var response = await client.CreateOrderAsync(request);
```

### Asynchronous Communication (Message Queues)

**RabbitMQ with .NET:**
```csharp
// Producer
public class OrderCreatedEventPublisher
{
    private readonly IConnection _connection;
    private readonly IModel _channel;
    
    public OrderCreatedEventPublisher()
    {
        var factory = new ConnectionFactory() { HostName = "localhost" };
        _connection = factory.CreateConnection();
        _channel = _connection.CreateModel();
        _channel.QueueDeclare("order_created", durable: true, exclusive: false);
    }
    
    public void Publish(OrderCreatedEvent orderEvent)
    {
        var body = Encoding.UTF8.GetBytes(JsonSerializer.Serialize(orderEvent));
        _channel.BasicPublish(exchange: "", routingKey: "order_created", body: body);
    }
}

// Consumer
public class InventoryUpdateConsumer
{
    public void StartConsuming()
    {
        var factory = new ConnectionFactory() { HostName = "localhost" };
        using var connection = factory.CreateConnection();
        using var channel = connection.CreateModel();
        
        var consumer = new EventingBasicConsumer(channel);
        consumer.Received += (model, ea) =>
        {
            var body = ea.Body.ToArray();
            var message = Encoding.UTF8.GetString(body);
            var orderEvent = JsonSerializer.Deserialize<OrderCreatedEvent>(message);
            
            // Update inventory
            UpdateInventory(orderEvent);
        };
        
        channel.BasicConsume("order_created", autoAck: true, consumer: consumer);
    }
}
```

### Communication Patterns Comparison

| Pattern | When to Use | Pros | Cons |
|---------|-------------|------|------|
| **gRPC** | Real-time, performance-critical | High performance, strongly typed | Complex setup, HTTP/2 only |
| **REST/HTTP** | Public APIs, web clients | Simple, cacheable, universal | Overhead, less efficient |
| **Message Queues** | Async processing, decoupling | Loose coupling, reliability | Complexity, message ordering |
| **Event Streaming** | Real-time analytics, CQRS | Real-time, scalable | Complex, overkill for simple cases |

---

## 3. Distributed Transactions and Saga Pattern {#distributed-transactions}

### The Problem with Distributed Transactions
In microservices, traditional ACID transactions across services are impractical due to the CAP theorem.

### Saga Pattern Implementation

**Choreography-Based Saga:**
```csharp
// Saga events
public class OrderCreatedEvent
{
    public Guid OrderId { get; set; }
    public decimal Amount { get; set; }
    public List<OrderItem> Items { get; set; }
}

public class PaymentProcessedEvent
{
    public Guid OrderId { get; set; }
    public bool Success { get; set; }
}

public class InventoryUpdatedEvent
{
    public Guid OrderId { get; set; }
    public bool Success { get; set; }
}

// Order Service
public class OrderService
{
    public async Task<Guid> CreateOrderAsync(Order order)
    {
        var orderId = Guid.NewGuid();
        
        // Save order with "Pending" status
        await _orderRepository.SaveAsync(order);
        
        // Publish event
        await _eventBus.PublishAsync(new OrderCreatedEvent 
        { 
            OrderId = orderId, 
            Amount = order.TotalAmount 
        });
        
        return orderId;
    }
}

// Payment Service (compensating action)
public class PaymentService
{
    public async Task HandleOrderCreated(OrderCreatedEvent @event)
    {
        try
        {
            // Process payment
            var paymentSuccess = await _paymentGateway.ChargeAsync(@event.Amount);
            
            await _eventBus.PublishAsync(new PaymentProcessedEvent 
            { 
                OrderId = @event.OrderId, 
                Success = paymentSuccess 
            });
            
            if (!paymentSuccess)
            {
                // Compensate - notify order service to cancel
                await _eventBus.PublishAsync(new OrderCancelledEvent 
                { 
                    OrderId = @event.OrderId, 
                    Reason = "Payment failed" 
                });
            }
        }
        catch (Exception ex)
        {
            // Compensating action
            await _eventBus.PublishAsync(new OrderCancelledEvent 
            { 
                OrderId = @event.OrderId, 
                Reason = $"Payment error: {ex.Message}" 
            });
        }
    }
}
```

**Orchestration-Based Saga:**
```csharp
public class OrderSagaOrchestrator
{
    private readonly ISagaRepository _sagaRepository;
    
    public async Task ProcessOrderCreation(Guid orderId)
    {
        var saga = new OrderCreationSaga(orderId);
        
        try
        {
            // Step 1: Validate inventory
            await _inventoryService.ReserveItemsAsync(orderId);
            saga.MarkInventoryReserved();
            
            // Step 2: Process payment
            await _paymentService.ProcessPaymentAsync(orderId);
            saga.MarkPaymentProcessed();
            
            // Step 3: Confirm order
            await _orderService.ConfirmOrderAsync(orderId);
            saga.MarkCompleted();
        }
        catch (Exception ex)
        {
            await Compensate(saga, ex);
        }
        
        await _sagaRepository.SaveAsync(saga);
    }
    
    private async Task Compensate(OrderCreationSaga saga, Exception ex)
    {
        if (saga.IsPaymentProcessed)
        {
            await _paymentService.RefundAsync(saga.OrderId);
        }
        
        if (saga.IsInventoryReserved)
        {
            await _inventoryService.ReleaseItemsAsync(saga.OrderId);
        }
        
        await _orderService.CancelOrderAsync(saga.OrderId, ex.Message);
    }
}
```

---

## 4. API Gateway and Service Discovery {#api-gateway}

### API Gateway Pattern
An API Gateway acts as a single entry point for all client requests and routes them to appropriate microservices.

**Ocelot API Gateway in .NET:**
```json
// ocelot.json
{
  "Routes": [
    {
      "DownstreamPathTemplate": "/api/orders",
      "DownstreamScheme": "https",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5001
        }
      ],
      "UpstreamPathTemplate": "/orders",
      "UpstreamHttpMethod": [ "GET", "POST" ]
    },
    {
      "DownstreamPathTemplate": "/api/products",
      "DownstreamScheme": "https",
      "ServiceName": "product-service",
      "UpstreamPathTemplate": "/products",
      "UpstreamHttpMethod": [ "GET" ]
    }
  ],
  "GlobalConfiguration": {
    "ServiceDiscoveryProvider": {
      "Host": "localhost",
      "Port": 8500,
      "Type": "Consul"
    }
  }
}
```

```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddOcelot();
builder.Configuration.AddJsonFile("ocelot.json");

var app = builder.Build();
app.UseOcelot().Wait();
app.Run();
```

### Service Discovery with Consul

**Service Registration:**
```csharp
public class ServiceRegistry : IHostedService
{
    private readonly IConsulClient _consulClient;
    private readonly string _serviceId;
    
    public ServiceRegistry(IConsulClient consulClient, IConfiguration config)
    {
        _consulClient = consulClient;
        _serviceId = $"order-service-{config["ASPNETCORE_ENVIRONMENT"]}";
    }
    
    public async Task StartAsync(CancellationToken cancellationToken)
    {
        var registration = new AgentServiceRegistration
        {
            ID = _serviceId,
            Name = "order-service",
            Address = "localhost",
            Port = 5001,
            Check = new AgentServiceCheck
            {
                HTTP = "https://localhost:5001/health",
                Interval = TimeSpan.FromSeconds(10),
                Timeout = TimeSpan.FromSeconds(5)
            }
        };
        
        await _consulClient.Agent.ServiceRegister(registration, cancellationToken);
    }
    
    public async Task StopAsync(CancellationToken cancellationToken)
    {
        await _consulClient.Agent.ServiceDeregister(_serviceId, cancellationToken);
    }
}
```

---

## 5. Circuit Breaker and Retry Patterns {#circuit-breaker}

### Polly Implementation in .NET

**Circuit Breaker with Retry:**
```csharp
public class ResilientHttpClient
{
    private readonly HttpClient _httpClient;
    private readonly AsyncCircuitBreakerPolicy<HttpResponseMessage> _circuitBreakerPolicy;
    private readonly AsyncRetryPolicy<HttpResponseMessage> _retryPolicy;
    
    public ResilientHttpClient()
    {
        _httpClient = new HttpClient();
        
        // Circuit Breaker: Opens after 5 consecutive failures
        _circuitBreakerPolicy = Policy<HttpResponseMessage>
            .Handle<HttpRequestException>()
            .OrResult(x => !x.IsSuccessStatusCode)
            .CircuitBreakerAsync(
                handledEventsAllowedBeforeBreaking: 5,
                durationOfBreak: TimeSpan.FromSeconds(30),
                onBreak: (result, breakDelay) => 
                {
                    Console.WriteLine($"Circuit broken! Will open for {breakDelay.TotalSeconds}s");
                },
                onReset: () => 
                {
                    Console.WriteLine("Circuit reset!");
                });
        
        // Retry Policy: 3 retries with exponential backoff
        _retryPolicy = Policy<HttpResponseMessage>
            .Handle<HttpRequestException>()
            .OrResult(x => !x.IsSuccessStatusCode)
            .WaitAndRetryAsync(
                retryCount: 3,
                sleepDurationProvider: retryAttempt => 
                    TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),
                onRetry: (outcome, timespan, retryCount, context) => 
                {
                    Console.WriteLine($"Retry {retryCount} after {timespan.TotalSeconds}s");
                });
    }
    
    public async Task<HttpResponseMessage> GetAsync(string url)
    {
        // Wrap retry policy with circuit breaker
        var resilientPolicy = Policy.WrapAsync(_retryPolicy, _circuitBreakerPolicy);
        
        return await resilientPolicy.ExecuteAsync(async () =>
        {
            return await _httpClient.GetAsync(url);
        });
    }
}
```

### Pattern Comparison

| Pattern | When to Use | Configuration | Considerations |
|---------|-------------|---------------|----------------|
| **Circuit Breaker** | Prevent cascade failures | Failure threshold, timeout | Monitor circuit state |
| **Retry** | Transient failures | Retry count, backoff | Idempotent operations only |
| **Bulkhead** | Resource isolation | Parallelization limits | Prevents resource exhaustion |
| **Timeout** | Slow dependencies | Timeout duration | Avoid hung requests |

---

## 6. Domain-Driven Design (DDD) {#ddd}

### Strategic Design

**Bounded Contexts and Context Mapping:**
```csharp
// Shared Kernel (shared between contexts)
public class SharedKernel
{
    public class Money
    {
        public decimal Amount { get; }
        public string Currency { get; }
        
        public Money(decimal amount, string currency)
        {
            Amount = amount;
            Currency = currency;
        }
    }
    
    public class Email
    {
        public string Value { get; }
        
        public Email(string value)
        {
            if (!IsValidEmail(value))
                throw new ArgumentException("Invalid email");
            Value = value;
        }
        
        private bool IsValidEmail(string email) => /* validation logic */;
    }
}

// Customer/Supplier relationship between contexts
public class OrderContext
{
    // Order context consumes customer data from Customer context
    public class CustomerInfo
    {
        public Guid CustomerId { get; set; }
        public string Name { get; set; }
        public Address ShippingAddress { get; set; }
    }
}
```

### Tactical Design

**Entities, Value Objects, and Aggregates:**
```csharp
// Entity (has identity)
public class Order : Entity<Guid>
{
    public OrderNumber OrderNumber { get; private set; }
    public CustomerId CustomerId { get; private set; }
    public Money TotalAmount { get; private set; }
    private List<OrderLine> _orderLines = new();
    public IReadOnlyList<OrderLine> OrderLines => _orderLines.AsReadOnly();
    
    public Order(Guid id, OrderNumber orderNumber, CustomerId customerId)
        : base(id)
    {
        OrderNumber = orderNumber;
        CustomerId = customerId;
    }
    
    public void AddOrderLine(ProductId productId, Quantity quantity, Money price)
    {
        var orderLine = new OrderLine(productId, quantity, price);
        _orderLines.Add(orderLine);
        RecalculateTotal();
    }
    
    private void RecalculateTotal()
    {
        TotalAmount = new Money(_orderLines.Sum(x => x.LineTotal.Amount), "USD");
    }
}

// Value Object (no identity, immutable)
public class OrderNumber : ValueObject
{
    public string Value { get; }
    
    public OrderNumber(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("Order number cannot be empty");
        Value = value;
    }
    
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Value;
    }
}

// Aggregate Root
public class Order : AggregateRoot<Guid>
{
    // Order is the aggregate root that controls access to order lines
    private List<OrderLine> _orderLines = new();
    
    public void AddOrderLine(ProductId productId, Quantity quantity, Money price)
    {
        // Business logic and invariants
        if (quantity.Value <= 0)
            throw new InvalidOperationException("Quantity must be positive");
            
        var orderLine = new OrderLine(productId, quantity, price);
        _orderLines.Add(orderLine);
        
        AddDomainEvent(new OrderLineAddedDomainEvent(Id, productId, quantity));
    }
}

// Domain Event
public class OrderLineAddedDomainEvent : DomainEvent
{
    public Guid OrderId { get; }
    public ProductId ProductId { get; }
    public Quantity Quantity { get; }
    
    public OrderLineAddedDomainEvent(Guid orderId, ProductId productId, Quantity quantity)
    {
        OrderId = orderId;
        ProductId = productId;
        Quantity = quantity;
    }
}
```

### Hexagonal Architecture (Ports and Adapters)

**Implementation in .NET:**
```csharp
// Domain Layer (core business logic)
public interface IOrderRepository // Port
{
    Task<Order> GetByIdAsync(Guid id);
    Task SaveAsync(Order order);
}

public class OrderService // Domain Service
{
    private readonly IOrderRepository _orderRepository;
    
    public OrderService(IOrderRepository orderRepository)
    {
        _orderRepository = orderRepository;
    }
    
    public async Task<Order> CreateOrderAsync(CustomerId customerId, List<OrderItem> items)
    {
        var order = new Order(Guid.NewGuid(), customerId, items);
        await _orderRepository.SaveAsync(order);
        return order;
    }
}

// Infrastructure Layer (adapters)
public class SqlOrderRepository : IOrderRepository // Adapter
{
    private readonly OrderDbContext _context;
    
    public SqlOrderRepository(OrderDbContext context)
    {
        _context = context;
    }
    
    public async Task<Order> GetByIdAsync(Guid id)
    {
        return await _context.Orders
            .Include(o => o.OrderLines)
            .FirstOrDefaultAsync(o => o.Id == id);
    }
    
    public async Task SaveAsync(Order order)
    {
        _context.Orders.Update(order);
        await _context.SaveChangesAsync();
    }
}

// API Layer (primary adapters)
[ApiController]
[Route("api/[controller]")]
public class OrdersController : ControllerBase
{
    private readonly OrderService _orderService;
    
    public OrdersController(OrderService orderService)
    {
        _orderService = orderService;
    }
    
    [HttpPost]
    public async Task<IActionResult> CreateOrder([FromBody] CreateOrderRequest request)
    {
        var order = await _orderService.CreateOrderAsync(
            new CustomerId(request.CustomerId), 
            request.Items);
            
        return Ok(new { OrderId = order.Id });
    }
}
```

---

## 7. Cloud-Native Development {#cloud-native}

### Containerization with Docker

**Dockerfile for .NET Application:**
```dockerfile
# Multi-stage build
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src

# Copy project files
COPY ["OrderService/OrderService.csproj", "OrderService/"]
COPY ["OrderService.Domain/OrderService.Domain.csproj", "OrderService.Domain/"]
COPY ["OrderService.Infrastructure/OrderService.Infrastructure.csproj", "OrderService.Infrastructure/"]

# Restore dependencies
RUN dotnet restore "OrderService/OrderService.csproj"

# Copy source code
COPY . .

# Build application
RUN dotnet build "OrderService/OrderService.csproj" -c Release -o /app/build

# Publish application
RUN dotnet publish "OrderService/OrderService.csproj" -c Release -o /app/publish

# Runtime image
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS runtime
WORKDIR /app

# Install necessary tools
RUN apt-get update && apt-get install -y curl

# Create non-root user
RUN groupadd -r appgroup && useradd -r -g appgroup appuser
USER appuser

COPY --from=build /app/publish .

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

ENTRYPOINT ["dotnet", "OrderService.dll"]
```

**Docker Compose:**
```yaml
version: '3.8'

services:
  order-service:
    build:
      context: .
      dockerfile: OrderService/Dockerfile
    ports:
      - "5001:8080"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ConnectionStrings__DefaultConnection=Server=sql-server;Database=Orders;User=sa;Password=YourPassword123;
    depends_on:
      - sql-server
      - rabbitmq

  sql-server:
    image: mcr.microsoft.com/mssql/server:2019-latest
    environment:
      SA_PASSWORD: "YourPassword123"
      ACCEPT_EULA: "Y"

  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5672:5672"
      - "15672:15672"
```

### Kubernetes Orchestration

**Kubernetes Deployment:**
```yaml
# order-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: order-service
  labels:
    app: order-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: order-service
  template:
    metadata:
      labels:
        app: order-service
    spec:
      containers:
      - name: order-service
        image: myregistry/order-service:latest
        ports:
        - containerPort: 8080
        env:
        - name: ASPNETCORE_ENVIRONMENT
          value: "Production"
        - name: ConnectionStrings__DefaultConnection
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: connection-string
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: order-service
spec:
  selector:
    app: order-service
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP
```

**Helm Chart:**
```yaml
# Chart.yaml
apiVersion: v2
name: order-service
description: A Helm chart for Kubernetes
type: application
version: 0.1.0
appVersion: "1.0.0"

# values.yaml
replicaCount: 3
image:
  repository: myregistry/order-service
  tag: latest
  pullPolicy: IfNotPresent
service:
  type: ClusterIP
  port: 80
ingress:
  enabled: true
  className: "nginx"
  annotations: {}
  hosts:
    - host: orders.mycompany.com
      paths:
        - path: /
          pathType: Prefix
resources:
  requests:
    cpu: 250m
    memory: 256Mi
  limits:
    cpu: 500m
    memory: 512Mi
```

### Infrastructure as Code

**Terraform for Azure:**
```hcl
# main.tf
terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~>3.0"
    }
  }
}

provider "azurerm" {
  features {}
}

resource "azurerm_resource_group" "main" {
  name     = "rg-orders-${var.environment}"
  location = var.location
}

resource "azurerm_service_plan" "main" {
  name                = "asp-orders-${var.environment}"
  resource_group_name = azurerm_resource_group.main.name
  location            = azurerm_resource_group.main.location
  os_type             = "Linux"
  sku_name            = "B1"
}

resource "azurerm_linux_web_app" "main" {
  name                = "app-orders-${var.environment}"
  resource_group_name = azurerm_resource_group.main.name
  location            = azurerm_service_plan.main.location
  service_plan_id     = azurerm_service_plan.main.id

  site_config {
    application_stack {
      dotnet_version = "8.0"
    }
    always_on = false
  }

  app_settings = {
    "ASPNETCORE_ENVIRONMENT" = var.environment
  }
}
```

**Bicep for Azure:**
```bicep
// main.bicep
param location string = resourceGroup().location
param environment string = 'dev'
param appServicePlanSku string = 'B1'

resource appServicePlan 'Microsoft.Web/serverfarms@2021-02-01' = {
  name: 'asp-orders-${environment}'
  location: location
  sku: {
    name: appServicePlanSku
  }
  properties: {
    reserved: true
  }
}

resource webApp 'Microsoft.Web/sites@2021-02-01' = {
  name: 'app-orders-${environment}'
  location: location
  properties: {
    serverFarmId: appServicePlan.id
    siteConfig: {
      linuxFxVersion: 'DOTNETCORE|8.0'
      alwaysOn: false
    }
    httpsOnly: true
  }
  identity: {
    type: 'SystemAssigned'
  }
}
```

---

## 8. Interview Questions and Answers {#interview-questions}

### Fundamental Questions

**Q1: What are the key differences between monolithic and microservices architecture?**

**Answer:**
| Aspect | Monolithic | Microservices |
|--------|------------|---------------|
| **Codebase** | Single, large codebase | Multiple, small codebases |
| **Database** | Shared database | Database per service |
| **Deployment** | Single unit deployment | Independent deployment |
| **Technology** | Homogeneous technology stack | Polyglot persistence/technology |
| **Scalability** | Scale entire application | Scale individual services |
| **Team Structure** | Large teams per layer | Small, cross-functional teams |

**Reasoning:** Microservices offer better scalability and team autonomy but introduce complexity in distributed systems.

---

**Q2: When would you choose synchronous vs asynchronous communication between services?**

**Answer:**
- **Synchronous (gRPC/REST):** 
  - When you need immediate response
  - Real-time user interactions
  - Simple request-response scenarios
  - Example: User authentication, price calculation

- **Asynchronous (Message Queues):**
  - When operations can be processed later
  - To decouple services and prevent cascading failures
  - Background processing, batch operations
  - Example: Order processing, email notifications

**Tricky Part:** Synchronous calls can create tight coupling and cascade failures. Always consider if the operation truly needs to be synchronous.

---

### Advanced Questions

**Q3: How do you handle distributed transactions in microservices without two-phase commit?**

**Answer:**
We use the Saga pattern, which can be implemented in two ways:

1. **Choreography-Based:** Each service publishes events and listens for events from other services
2. **Orchestration-Based:** A central orchestrator coordinates the transaction steps

```csharp
// Choreography example - compensation actions
public class OrderSaga
{
    public async Task HandleOrderCreated(OrderCreatedEvent @event)
    {
        try
        {
            // Step 1: Reserve inventory
            await _inventoryService.ReserveAsync(@event.OrderId, @event.Items);
            
            // Step 2: Process payment
            await _paymentService.ProcessAsync(@event.OrderId, @event.Amount);
            
            // Step 3: Confirm order
            await _orderService.ConfirmAsync(@event.OrderId);
        }
        catch (Exception ex)
        {
            // Compensating transactions
            await _inventoryService.ReleaseAsync(@event.OrderId);
            await _paymentService.RefundAsync(@event.OrderId);
            await _orderService.CancelAsync(@event.OrderId, ex.Message);
        }
    }
}
```

**Tricky Part:** Ensuring idempotency in saga steps and handling partial failures where some services succeed while others fail.

---

**Q4: What is the difference between circuit breaker and retry patterns? When would you use each?**

**Answer:**

| Pattern | Purpose | When to Use |
|---------|---------|-------------|
| **Circuit Breaker** | Prevents repeated calls to failing services | When downstream service is consistently failing |
| **Retry** | Handles transient failures | When failures are temporary and likely to succeed on retry |

**Combined Usage:**
```csharp
var policy = Policy<HttpResponseMessage>
    .Handle<HttpRequestException>()
    .OrResult(x => !x.IsSuccessStatusCode)
    .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30))
    .WrapAsync(Policy
        .Handle<HttpRequestException>()
        .WaitAndRetryAsync(3, retryAttempt => 
            TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))));
```

**Tricky Part:** Circuit breakers need proper monitoring and tuning. Too sensitive settings can open the circuit unnecessarily.

---

**Q5: How do you implement service discovery in a dynamic microservices environment?**

**Answer:**
Service discovery can be implemented as:

1. **Client-Side Discovery:** Clients query service registry and load balance requests
2. **Server-Side Discovery:** Load balancer queries registry and routes requests

**With Consul in .NET:**
```csharp
// Registration
services.AddConsul(config =>
{
    config.Address = new Uri("http://consul:8500");
})
.AddServiceRegistration(options =>
{
    options.ID = $"order-service-{Guid.NewGuid()}";
    options.Name = "order-service";
    options.Address = "order-service";
    options.Port = 80;
    options.Check = new AgentServiceCheck
    {
        HTTP = "http://order-service/health",
        Interval = TimeSpan.FromSeconds(10)
    };
});

// Discovery
services.AddHttpClient<IPaymentService, PaymentService>()
    .AddServiceDiscovery(serviceDiscovery => 
    {
        serviceDiscovery.UseConsul();
    });
```

**Tricky Part:** Handling service registry failures and ensuring services properly deregister when shutting down.

---

**Q6: What are the key principles of Domain-Driven Design and how do they apply to microservices?**

**Answer:**
**Strategic Design:**
- **Bounded Contexts:** Define clear boundaries for each microservice
- **Ubiquitous Language:** Common language between developers and domain experts
- **Context Mapping:** Define relationships between bounded contexts

**Tactical Design:**
- **Entities:** Objects with identity (e.g., Order, Customer)
- **Value Objects:** Immutable objects without identity (e.g., Money, Address)
- **Aggregates:** Clusters of related objects treated as a unit
- **Domain Events:** Events representing business occurrences

**Application to Microservices:**
```csharp
// Each microservice represents a bounded context
public class OrderingContext  // Microservice boundary
{
    // Aggregate root
    public class Order : AggregateRoot
    {
        private List<OrderItem> _items = new();
        
        public void AddItem(ProductId productId, int quantity)
        {
            // Domain logic and invariants
            if (quantity <= 0) throw new DomainException("Invalid quantity");
            
            _items.Add(new OrderItem(productId, quantity));
            AddDomainEvent(new OrderItemAddedEvent(Id, productId, quantity));
        }
    }
    
    // Domain service for complex logic
    public class OrderPricingService
    {
        public Money CalculateTotal(Order order, CustomerDiscount discount)
        {
            // Complex pricing logic
        }
    }
}
```

**Tricky Part:** Determining the right boundaries for microservices and managing relationships between bounded contexts.

---

**Q7: How does hexagonal architecture help in building maintainable microservices?**

**Answer:**
Hexagonal architecture (ports and adapters) provides:

1. **Separation of Concerns:** Domain logic separated from infrastructure
2. **Testability:** Easy to mock dependencies
3. **Flexibility:** Easy to change technology stack

**Implementation:**
```csharp
// Domain layer (core business logic)
public interface IOrderRepository // Port
{
    Task<Order> GetByIdAsync(OrderId id);
    Task SaveAsync(Order order);
}

// Application layer (use cases)
public class CreateOrderUseCase
{
    private readonly IOrderRepository _orderRepository;
    private readonly IEventBus _eventBus;
    
    public async Task<OrderId> Execute(CreateOrderCommand command)
    {
        var order = Order.Create(command.CustomerId, command.Items);
        await _orderRepository.SaveAsync(order);
        await _eventBus.Publish(order.DomainEvents);
        return order.Id;
    }
}

// Infrastructure layer (adapters)
public class SqlOrderRepository : IOrderRepository // Adapter
{
    // SQL Server implementation
}

public class RabbitMqEventBus : IEventBus // Adapter  
{
    // RabbitMQ implementation
}
```

**Tricky Part:** Avoiding infrastructure concerns leaking into the domain layer and managing dependency direction.

---

**Q8: What are the challenges of data management in microservices and how do you address them?**

**Answer:**
**Challenges:**
1. **Data Consistency:** ACID transactions across services are impossible
2. **Data Duplication:** Services may need to duplicate data for autonomy
3. **Querying Data:** Joining data across service boundaries is complex

**Solutions:**
1. **Saga Pattern:** For data consistency
2. **Event Sourcing:** Maintain state as sequence of events
3. **CQRS:** Separate read and write models
4. **API Composition:** Aggregate data from multiple services

**CQRS Implementation:**
```csharp
// Command side (write model)
public class OrderCommandService
{
    public async Task<OrderId> CreateOrderAsync(CreateOrderCommand command)
    {
        var order = new Order(command.CustomerId, command.Items);
        await _orderRepository.AddAsync(order);
        
        // Publish event for read model update
        await _eventBus.Publish(new OrderCreatedEvent(order.Id, order.Items));
        return order.Id;
    }
}

// Query side (read model)
public class OrderQueryService
{
    public async Task<OrderView> GetOrderAsync(OrderId id)
    {
        // Read from optimized read database
        return await _orderReadRepository.GetByIdAsync(id);
    }
}

// Event handler for updating read model
public class OrderReadModelUpdater
{
    public async Task Handle(OrderCreatedEvent @event)
    {
        var orderView = new OrderView
        {
            OrderId = @event.OrderId,
            Items = @event.Items,
            Status = "Created"
        };
        await _orderReadRepository.AddAsync(orderView);
    }
}
```

**Tricky Part:** Ensuring eventual consistency and handling read model update failures.

---

### Tricky Scenario-Based Questions

**Q9: You have a service that's experiencing high latency and occasional timeouts. How would you diagnose and fix this?**

**Answer:**
**Diagnosis Steps:**
1. **Monitoring:** Check metrics (CPU, memory, response times, error rates)
2. **Logging:** Analyze request flows and identify bottlenecks
3. **Tracing:** Use distributed tracing to see request flow across services
4. **Profiling:** Use performance profilers to identify code-level issues

**Solutions:**
```csharp
// Implement resilience patterns
services.AddHttpClient<ISlowService, SlowService>()
    .AddPolicyHandler(GetRetryPolicy())
    .AddPolicyHandler(GetCircuitBreakerPolicy())
    .AddPolicyHandler(GetTimeoutPolicy());

private static IAsyncPolicy<HttpResponseMessage> GetTimeoutPolicy()
{
    return Policy.TimeoutAsync<HttpResponseMessage>(TimeSpan.FromSeconds(10));
}

private static IAsyncPolicy<HttpResponseMessage> GetCircuitBreakerPolicy()
{
    return HttpPolicyExtensions
        .HandleTransientHttpError()
        .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30));
}
```

**Tricky Part:** Distinguishing between transient failures and genuine performance issues that need architectural changes.

---

**Q10: How would you handle versioning in microservices APIs?**

**Answer:**
**API Versioning Strategies:**
1. **URI Versioning:** `/api/v1/orders`, `/api/v2/orders`
2. **Query String Versioning:** `/api/orders?api-version=1.0`
3. **Header Versioning:** `Accept: application/vnd
