# Middleware Development - Comprehensive Guide

## Table of Contents
1. [Introduction to Middleware](#introduction)
2. [Custom Middleware Components](#custom-middleware)
3. [Middleware Pipeline Order and Branching](#pipeline-order)
4. [Exception Handling and Logging Middleware](#exception-handling)
5. [Request/Response Transformation](#request-response)
6. [Comparison Tables](#comparison)
7. [Interview Questions & Answers](#interview-questions)

---

## 1. Introduction to Middleware <a name="introduction"></a>

### What is Middleware?
Middleware is software components that are assembled into an application pipeline to handle requests and responses. Each component:
- Chooses whether to pass the request to the next component
- Can perform work before and after the next component in the pipeline

### Basic Middleware Structure
```csharp
public class CustomMiddleware
{
    private readonly RequestDelegate _next;

    public CustomMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Pre-processing logic
        await _next(context); // Call next middleware
        // Post-processing logic
    }
}
```

---

## 2. Custom Middleware Components <a name="custom-middleware"></a>

### Creating Custom Middleware

#### Method 1: Class-based Middleware
```csharp
public class TimingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<TimingMiddleware> _logger;

    public TimingMiddleware(RequestDelegate next, ILogger<TimingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var stopwatch = Stopwatch.StartNew();
        
        // Call next middleware in pipeline
        await _next(context);
        
        stopwatch.Stop();
        _logger.LogInformation($"Request took: {stopwatch.ElapsedMilliseconds}ms");
    }
}

// Extension method for easy registration
public static class TimingMiddlewareExtensions
{
    public static IApplicationBuilder UseTimingMiddleware(this IApplicationBuilder app)
    {
        return app.UseMiddleware<TimingMiddleware>();
    }
}
```

#### Method 2: Inline Middleware
```csharp
app.Use(async (context, next) =>
{
    // Pre-processing
    var start = DateTime.UtcNow;
    
    await next(); // Call next middleware
    
    // Post-processing
    var duration = DateTime.UtcNow - start;
    Console.WriteLine($"Request took: {duration.TotalMilliseconds}ms");
});
```

#### Method 3: Factory-based Middleware
```csharp
public class FactoryActivatedMiddleware : IMiddleware
{
    private readonly ILogger<FactoryActivatedMiddleware> _logger;

    public FactoryActivatedMiddleware(ILogger<FactoryActivatedMiddleware> logger)
    {
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        _logger.LogInformation("Factory-activated middleware executing");
        await next(context);
    }
}

// Registration in Startup.cs
services.AddSingleton<FactoryActivatedMiddleware>();
```

### Middleware Dependencies
Middleware supports dependency injection through constructor parameters or the `InvokeAsync` method:

```csharp
public class DependencyInjectionMiddleware
{
    private readonly RequestDelegate _next;

    public DependencyInjectionMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    // Dependencies can be injected via method parameters
    public async Task InvokeAsync(HttpContext context, IMyService service)
    {
        service.DoSomething();
        await _next(context);
    }
}
```

---

## 3. Middleware Pipeline Order and Branching <a name="pipeline-order"></a>

### Pipeline Order Importance
The order of middleware registration is CRITICAL - it determines the execution sequence.

### Typical Pipeline Order
```csharp
public void Configure(IApplicationBuilder app)
{
    // Exception handling FIRST (catches exceptions from later middleware)
    app.UseExceptionHandler("/error");
    
    // Static files before authentication (no need to auth static files)
    app.UseStaticFiles();
    
    // Authentication before authorization
    app.UseAuthentication();
    app.UseAuthorization();
    
    // Custom middleware
    app.UseMyCustomMiddleware();
    
    // Endpoint routing LAST
    app.UseRouting();
    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
    });
}
```

### Middleware Branching
Branching allows creating separate pipelines for specific routes.

#### Map Branching
```csharp
app.Map("/admin", adminApp =>
{
    adminApp.UseExceptionHandler("/admin-error");
    adminApp.UseAuthentication();
    adminApp.UseAuthorization();
    adminApp.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
    });
});

app.Map("/api", apiApp =>
{
    apiApp.UseMiddleware<ApiMiddleware>();
    apiApp.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
    });
});
```

#### MapWhen Branching (Conditional)
```csharp
app.MapWhen(context => context.Request.Query.ContainsKey("version"), 
    versionApp =>
{
    versionApp.UseMiddleware<VersionMiddleware>();
});
```

#### UseWhen Branching (Rejoins main pipeline)
```csharp
app.UseWhen(context => context.Request.Path.StartsWithSegments("/api"), 
    apiBranch =>
{
    apiBranch.UseMiddleware<ApiHeaderMiddleware>();
});
// This middleware rejoins the main pipeline
app.UseMiddleware<CommonMiddleware>();
```

### Terminal Middleware
Middleware that doesn't call `next()` and ends the pipeline:

```csharp
app.Run(async context =>
{
    await context.Response.WriteAsync("Terminal middleware - pipeline ends here");
});

// Anything after Run will NOT execute
app.UseMiddleware<ThisWillNotExecute>();
```

---

## 4. Exception Handling and Logging Middleware <a name="exception-handling"></a>

### Exception Handling Strategies

#### Global Exception Handler
```csharp
public class GlobalExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionMiddleware> _logger;
    private readonly IWebHostEnvironment _env;

    public GlobalExceptionMiddleware(RequestDelegate next, 
        ILogger<GlobalExceptionMiddleware> logger, 
        IWebHostEnvironment env)
    {
        _next = next;
        _logger = logger;
        _env = env;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An unhandled exception occurred");
            await HandleExceptionAsync(context, ex);
        }
    }

    private async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        context.Response.ContentType = "application/json";
        context.Response.StatusCode = exception switch
        {
            UnauthorizedAccessException => StatusCodes.Status401Unauthorized,
            NotImplementedException => StatusCodes.Status501NotImplemented,
            _ => StatusCodes.Status500InternalServerError
        };

        var response = _env.IsDevelopment() 
            ? new { error = exception.Message, stackTrace = exception.StackTrace }
            : new { error = "An error occurred. Please try again later." };

        await context.Response.WriteAsync(JsonSerializer.Serialize(response));
    }
}
```

#### Built-in Exception Handling
```csharp
// Development environment
if (env.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
else
{
    app.UseExceptionHandler("/error");
    app.UseHsts();
}

// Custom error handling route
app.Map("/error", errorApp =>
{
    errorApp.Run(async context =>
    {
        var exceptionHandler = context.Features.Get<IExceptionHandlerPathFeature>();
        // Handle exception
        await context.Response.WriteAsync("Error occurred");
    });
});
```

### Logging Middleware
```csharp
public class RequestLoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<RequestLoggingMiddleware> _logger;

    public RequestLoggingMiddleware(RequestDelegate next, ILogger<RequestLoggingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var stopwatch = Stopwatch.StartNew();
        var request = context.Request;
        
        // Log request details
        _logger.LogInformation("HTTP {Method} {Path} started", 
            request.Method, request.Path);

        try
        {
            await _next(context);
            var response = context.Response;
            
            _logger.LogInformation("HTTP {Method} {Path} completed with {StatusCode} in {Elapsed}ms",
                request.Method, request.Path, response.StatusCode, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "HTTP {Method} {Path} failed with exception", 
                request.Method, request.Path);
            throw; // Re-throw for global exception handler
        }
    }
}
```

### Correlation ID Middleware
```csharp
public class CorrelationMiddleware
{
    private readonly RequestDelegate _next;

    public CorrelationMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context, ILogger<CorrelationMiddleware> logger)
    {
        var correlationId = context.Request.Headers["X-Correlation-ID"].FirstOrDefault() 
                           ?? Guid.NewGuid().ToString();
        
        // Add to response headers
        context.Response.Headers["X-Correlation-ID"] = correlationId;
        
        // Using LogScope for correlation ID in all logs
        using (logger.BeginScope("{CorrelationId}", correlationId))
        {
            await _next(context);
        }
    }
}
```

---

## 5. Request/Response Transformation <a name="request-response"></a>

### Request Transformation
```csharp
public class RequestTransformationMiddleware
{
    private readonly RequestDelegate _next;

    public RequestTransformationMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Enable buffering to read request body multiple times
        context.Request.EnableBuffering();
        
        var originalBodyStream = context.Response.Body;
        
        try
        {
            // Read and transform request
            await TransformRequest(context.Request);
            
            // Capture response
            using var responseBody = new MemoryStream();
            context.Response.Body = responseBody;
            
            await _next(context);
            
            // Transform response
            await TransformResponse(context.Response, responseBody, originalBodyStream);
        }
        finally
        {
            context.Response.Body = originalBodyStream;
        }
    }

    private async Task TransformRequest(HttpRequest request)
    {
        if (request.ContentType?.Contains("application/json") == true)
        {
            request.Headers["X-Original-ContentType"] = request.ContentType;
            // Could transform JSON request here
        }
    }

    private async Task TransformResponse(HttpResponse response, MemoryStream responseBody, Stream originalBody)
    {
        responseBody.Seek(0, SeekOrigin.Begin);
        var responseText = await new StreamReader(responseBody).ReadToEndAsync();
        
        // Transform response text if needed
        if (!string.IsNullOrEmpty(responseText) && response.ContentType?.Contains("application/json") == true)
        {
            var transformedResponse = TransformJsonResponse(responseText);
            var bytes = Encoding.UTF8.GetBytes(transformedResponse);
            await originalBody.WriteAsync(bytes, 0, bytes.Length);
        }
        else
        {
            await responseBody.CopyToAsync(originalBody);
        }
    }
    
    private string TransformJsonResponse(string originalJson) 
    {
        // Your transformation logic here
        return originalJson;
    }
}
```

### Response Caching Middleware
```csharp
public class ResponseCachingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IMemoryCache _cache;

    public ResponseCachingMiddleware(RequestDelegate next, IMemoryCache cache)
    {
        _next = next;
        _cache = cache;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var cacheKey = GenerateCacheKey(context.Request);
        
        if (_cache.TryGetValue(cacheKey, out byte[] cachedResponse))
        {
            context.Response.Headers["X-Cache"] = "HIT";
            await context.Response.Body.WriteAsync(cachedResponse, 0, cachedResponse.Length);
            return;
        }

        using var responseBody = new MemoryStream();
        var originalBody = context.Response.Body;
        context.Response.Body = responseBody;

        await _next(context);

        if (context.Response.StatusCode == 200) // Only cache successful responses
        {
            var responseData = responseBody.ToArray();
            _cache.Set(cacheKey, responseData, TimeSpan.FromMinutes(5));
            context.Response.Headers["X-Cache"] = "MISS";
            
            await originalBody.WriteAsync(responseData, 0, responseData.Length);
        }
    }

    private string GenerateCacheKey(HttpRequest request)
    {
        return $"{request.Path}{request.QueryString}";
    }
}
```

### Content Negotiation Middleware
```csharp
public class ContentNegotiationMiddleware
{
    private readonly RequestDelegate _next;

    public ContentNegotiationMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Check Accept header and transform response accordingly
        var acceptHeader = context.Request.Headers["Accept"].ToString();
        
        if (acceptHeader.Contains("application/xml"))
        {
            // Set response to XML
            context.Response.OnStarting(state =>
            {
                var httpContext = (HttpContext)state;
                httpContext.Response.ContentType = "application/xml";
                return Task.CompletedTask;
            }, context);
        }

        await _next(context);
    }
}
```

---

## 6. Comparison Tables <a name="comparison"></a>

### Middleware Registration Methods

| Method | Syntax | Use Case | Pros | Cons |
|--------|--------|----------|------|------|
| **UseMiddleware** | `app.UseMiddleware<T>()` | Class-based middleware with dependencies | Full DI support, testable | More boilerplate |
| **Use** | `app.Use(async (ctx, next) => {})` | Simple, inline middleware | Quick setup, no classes | Hard to test, no DI |
| **Run** | `app.Run(async ctx => {})` | Terminal middleware | Ends pipeline, simple | No next middleware |
| **Map** | `app.Map("/path", branch => {})` | Route-specific branching | Isolated pipelines | Doesn't rejoin main pipeline |
| **MapWhen** | `app.MapWhen(condition, branch => {})` | Conditional branching | Flexible conditions | Complex conditions |
| **UseWhen** | `app.UseWhen(condition, branch => {})` | Conditional that rejoins | Maintains pipeline | Can be confusing |

### Exception Handling Strategies

| Strategy | Implementation | When to Use | Considerations |
|----------|----------------|-------------|----------------|
| **Developer Exception Page** | `UseDeveloperExceptionPage()` | Development only | Shows detailed errors, security risk in production |
| **Custom Exception Middleware** | Class-based middleware | Full control over error handling | Must be first in pipeline |
| **Built-in Exception Handler** | `UseExceptionHandler()` | Production environments | Configurable error paths |
| **Exception Filters** | Action filters in MVC | Controller-specific handling | Only catches MVC exceptions |

### Request/Response Transformation Techniques

| Technique | Middleware Type | Use Case | Performance Impact |
|-----------|-----------------|----------|-------------------|
| **Stream Wrapping** | Response body stream replacement | Response transformation | Low, memory streams |
| **Header Modification** | Simple middleware | CORS, security headers | Minimal |
| **Body Buffering** | EnableBuffering() | Multiple reads of request body | High, memory usage |
| **Response Caching** | MemoryCache integration | Frequent identical responses | High performance gain |

### When to Use Different Middleware Patterns

| Scenario | Recommended Pattern | Reasoning |
|----------|---------------------|-----------|
| **Simple logging** | Inline middleware (`Use`) | Quick implementation, minimal dependencies |
| **Complex business logic** | Class-based middleware | DI support, testability, separation of concerns |
| **API-specific processing** | `Map` or `MapWhen` | Isolation, different pipeline requirements |
| **Error handling** | Class-based (first in pipeline) | Catches all exceptions, global coverage |
| **Authentication** | Built-in `UseAuthentication()` | Security, standard implementation |
| **Response transformation** | Stream replacement middleware | Can modify response content |

---

## 7. Interview Questions & Answers <a name="interview-questions"></a>

### Basic Questions

**Q1: What is middleware in ASP.NET Core and how does it work?**
```csharp
// Answer with example:
public class SimpleMiddleware
{
    private readonly RequestDelegate _next;
    
    public SimpleMiddleware(RequestDelegate next)
    {
        _next = next;
    }
    
    public async Task InvokeAsync(HttpContext context)
    {
        // Pre-processing
        await _next(context); // Call next middleware
        // Post-processing
    }
}
```
**Reasoning:** Middleware components form a pipeline where each can process requests and responses. The order of execution is determined by the registration order.

**Q2: Why is middleware order important? Provide an example.**
```csharp
// Correct order:
app.UseExceptionHandler(); // First - catches exceptions
app.UseHttpsRedirection();
app.UseStaticFiles(); // Before authentication for performance
app.UseAuthentication();
app.UseAuthorization();
app.UseRouting();
app.UseEndpoints(...);
```
**Reasoning:** Exception handling must be first to catch errors. Static files before auth to avoid unnecessary authentication. Routing should be before endpoints.

### Intermediate Questions

**Q3: What's the difference between `Use`, `Run`, and `Map`?**
```csharp
app.Use(async (context, next) =>
{
    // This executes and calls next
    await next();
});

app.Run(async context =>
{
    // This executes and pipeline ends
    await context.Response.WriteAsync("Done");
});

app.Map("/admin", adminApp =>
{
    // This creates a separate branch for /admin
    adminApp.Run(...);
});
```
**Reasoning:** `Use` calls next middleware, `Run` is terminal, `Map` creates branches.

**Q4: How do you handle dependencies in middleware?**
```csharp
// Constructor injection (singleton dependencies)
public class MiddlewareWithConstructorDI
{
    private readonly RequestDelegate _next;
    private readonly ILogger _logger; // Singleton

    public MiddlewareWithConstructorDI(RequestDelegate next, ILogger logger)
    {
        _next = next;
        _logger = logger;
    }
}

// Method injection (scoped dependencies)
public async Task InvokeAsync(HttpContext context, IMyScopedService service)
{
    // Scoped service injected per request
    service.DoSomething();
    await _next(context);
}
```
**Reasoning:** Constructor gets singleton dependencies, method parameters get scoped dependencies.

### Advanced/Tricky Questions

**Q5: What happens if middleware doesn't call `next()`?**
```csharp
public async Task InvokeAsync(HttpContext context)
{
    if (context.Request.Path.StartsWithSegments("/blocked"))
    {
        context.Response.StatusCode = 403;
        await context.Response.WriteAsync("Blocked");
        return; // Pipeline short-circuited
    }
    await _next(context); // Not called for /blocked paths
}
```
**Reasoning:** The pipeline short-circuits. Subsequent middleware won't execute. Useful for authentication, caching, or blocking certain requests.

**Q6: How can you modify the response body after other middleware have written to it?**
```csharp
public async Task InvokeAsync(HttpContext context)
{
    var originalBodyStream = context.Response.Body;
    using var responseBody = new MemoryStream();
    context.Response.Body = responseBody;

    await _next(context); // All middleware write to responseBody

    responseBody.Seek(0, SeekOrigin.Begin);
    var responseText = await new StreamReader(responseBody).ReadToEndAsync();
    
    // Modify response
    var modifiedResponse = responseText.ToUpper();
    
    var bytes = Encoding.UTF8.GetBytes(modifiedResponse);
    await originalBodyStream.WriteAsync(bytes, 0, bytes.Length);
}
```
**Tricky Part:** You must replace the response stream early and copy back at the end. MemoryStream allows reading what was written.

**Q7: How does exception handling middleware work and why must it be first?**
```csharp
public async Task InvokeAsync(HttpContext context)
{
    try
    {
        await _next(context); // Wrap the entire pipeline
    }
    catch (Exception ex)
    {
        // Handle exception
        await HandleException(context, ex);
    }
}
```
**Reasoning:** Being first ensures it catches exceptions from ALL subsequent middleware. If it's not first, exceptions from earlier middleware won't be caught.

**Q8: What's the difference between `Map` and `UseWhen`?**
```csharp
// Map - creates completely separate pipeline
app.Map("/api", apiApp =>
{
    apiApp.UseMiddleware<ApiMiddleware>();
    // This is isolated, doesn't rejoin main pipeline
});

// UseWhen - branches and rejoins
app.UseWhen(context => context.Request.Path.StartsWithSegments("/api"), 
    apiBranch =>
{
    apiBranch.UseMiddleware<ApiMiddleware>();
});
// Middleware after this will execute for ALL requests
app.UseMiddleware<CommonMiddleware>();
```
**Tricky Part:** `Map` creates isolated pipelines, `UseWhen` branches but rejoins the main pipeline.

**Q9: How do you implement middleware that needs to run both before and after subsequent middleware?**
```csharp
public async Task InvokeAsync(HttpContext context)
{
    // Pre-processing logic
    var stopwatch = Stopwatch.StartNew();
    
    // Call next middleware in pipeline
    await _next(context);
    
    // Post-processing logic
    stopwatch.Stop();
    LogDuration(stopwatch.Elapsed);
}
```
**Reasoning:** Code before `await _next()` runs before subsequent middleware, code after runs after they complete.

**Q10: What are the performance considerations when writing middleware?**
```csharp
// Bad - reads body synchronously
public async Task InvokeAsync(HttpContext context)
{
    using var reader = new StreamReader(context.Request.Body);
    var body = reader.ReadToEnd(); // Blocks thread
    await _next(context);
}

// Good - async all the way
public async Task InvokeAsync(HttpContext context)
{
    using var reader = new StreamReader(context.Request.Body);
    var body = await reader.ReadToEndAsync(); // Async
    await _next(context);
}
```
**Key Considerations:** 
- Use async methods to avoid thread blocking
- Be careful with body buffering (memory usage)
- Avoid expensive operations in middleware
- Consider using `IMemoryCache` for repeated operations

### Follow-up Questions

**Q11: How would you test custom middleware?**
```csharp
// Example using TestServer
public class MiddlewareTests
{
    [Fact]
    public async Task Middleware_AddsCustomHeader()
    {
        var hostBuilder = new WebHostBuilder()
            .ConfigureServices(services => services.AddMyServices())
            .Configure(app => 
            {
                app.UseMiddleware<CustomHeaderMiddleware>();
                app.Run(async ctx => await ctx.Response.WriteAsync("Test"));
            });

        using var server = new TestServer(hostBuilder);
        var client = server.CreateClient();
        
        var response = await client.GetAsync("/");
        Assert.True(response.Headers.Contains("X-Custom-Header"));
    }
}
```

**Q12: What happens when middleware throws an exception?**
```csharp
// If no exception handling middleware:
// - The exception propagates up
// - Server returns 500 Internal Server Error
// - Details may be exposed in development

// With exception handling middleware:
public async Task InvokeAsync(HttpContext context)
{
    try
    {
        await _next(context);
    }
    catch (Exception ex)
    {
        // Convert exception to proper HTTP response
        context.Response.StatusCode = 500;
        await context.Response.WriteAsync("Error handled gracefully");
    }
}
```

**Q13: How can middleware access endpoint routing information?**
```csharp
public async Task InvokeAsync(HttpContext context)
{
    var endpoint = context.GetEndpoint();
    if (endpoint != null)
    {
        var routePattern = (endpoint as RouteEndpoint)?.RoutePattern?.RawText;
        // Use routing information
    }
    await _next(context);
}

// Must be placed after UseRouting()
app.UseRouting();
app.UseMiddleware<MyRoutingAwareMiddleware>();
app.UseEndpoints(...);
```

**Q14: What's the lifetime of services injected into middleware?**
```csharp
public class MiddlewareWithDependencies
{
    private readonly ISingletonService _singleton;
    
    public MiddlewareWithDependencies(RequestDelegate next, ISingletonService singleton)
    {
        _singleton = singleton; // Singleton - same instance for all requests
    }
    
    public async Task InvokeAsync(HttpContext context, IScopedService scoped, ITransientService transient)
    {
        // scoped - same instance per request
        // transient - new instance each time
        await _next(context);
    }
}
```

### Real-world Scenario Questions

**Q15: Design a middleware that rate limits API requests**
```csharp
public class RateLimitingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IMemoryCache _cache;
    
    public RateLimitingMiddleware(RequestDelegate next, IMemoryCache cache)
    {
        _next = next;
        _cache = cache;
    }
    
    public async Task InvokeAsync(HttpContext context)
    {
        var clientIp = context.Connection.RemoteIpAddress.ToString();
        var cacheKey = $"rate_limit_{clientIp}";
        
        if (_cache.TryGetValue(cacheKey, out int requestCount) && requestCount > 100)
        {
            context.Response.StatusCode = 429; // Too Many Requests
            return;
        }
        
        // Increment counter with expiration
        var options = new MemoryCacheEntryOptions { AbsoluteExpiration = DateTime.Now.AddMinutes(1) };
        _cache.Set(cacheKey, requestCount + 1, options);
        
        await _next(context);
    }
}
```

This comprehensive guide covers all aspects of middleware development with practical examples and interview preparation materials. The key to mastering middleware is understanding the pipeline flow and practicing with real-world scenarios.
