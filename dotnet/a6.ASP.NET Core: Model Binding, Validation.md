# Model Binding and Validation - Complete Guide

## 1. Model Binding Attributes

### Overview
Model binding in ASP.NET Core automatically maps HTTP request data to controller action parameters or model properties.

### Detailed Explanation

#### FromBody Attribute
**Purpose**: Binds data from the request body (typically JSON/XML in API requests)

```csharp
[HttpPost]
public IActionResult CreateProduct([FromBody] Product product)
{
    // product is populated from JSON/XML in request body
    return Ok(product);
}
```

**When to Use**:
- POST, PUT, PATCH requests with JSON/XML payloads
- Web API endpoints
- Complex object types

**Key Points**:
- Requires `Content-Type` header (application/json, application/xml)
- Uses input formatters configured in MVC pipeline
- By default, only binds from body for complex types in API controllers

#### FromQuery Attribute
**Purpose**: Binds data from query string parameters

```csharp
[HttpGet]
public IActionResult GetProducts([FromQuery] string category, [FromQuery] int page = 1)
{
    // category and page come from ?category=electronics&page=2
    return Ok(_service.GetProducts(category, page));
}
```

**When to Use**:
- GET requests with query parameters
- Filtering, pagination, sorting parameters
- Simple types that can be represented in URL

#### FromRoute Attribute
**Purpose**: Binds data from route parameters

```csharp
[HttpGet("{id:int}")]
public IActionResult GetProduct([FromRoute] int id)
{
    // id comes from route /api/products/5
    return Ok(_service.GetProduct(id));
}
```

**When to Use**:
- Resource identifiers in RESTful APIs
- Required parameters that are part of URL structure
- When you want clean, readable URLs

#### FromHeader Attribute
**Purpose**: Binds data from HTTP headers

```csharp
[HttpGet]
public IActionResult GetUser([FromHeader(Name = "X-User-Id")] string userId)
{
    // userId comes from X-User-Id header
    return Ok(_service.GetUser(userId));
}
```

**When to Use**:
- Authentication tokens (Authorization header)
- API versioning headers
- Custom headers for cross-cutting concerns

### Attribute Comparison Table

| Attribute | Source | Typical Use Case | Data Type | Required? |
|-----------|--------|------------------|-----------|-----------|
| `[FromBody]` | Request Body | API payloads, complex objects | Complex | Optional for complex types |
| `[FromQuery]` | Query String | Filters, pagination, search | Simple | Optional |
| `[FromRoute]` | URL Route | Resource IDs, required params | Simple | Required |
| `[FromHeader]` | HTTP Headers | Auth, versioning, metadata | Simple | Optional |
| `[FromForm]` | Form Data | File uploads, form submissions | Simple/Complex | Optional |
| `[FromServices]` | DI Container | Service dependencies | Services | Optional |

### When to Use Which Attribute

**Scenario 1: RESTful API**
```csharp
[HttpGet("{id}")]                    // FromRoute - required ID
public IActionResult GetProduct(
    [FromRoute] int id,
    [FromQuery] string include = "")  // FromQuery - optional expansion
{
    // Implementation
}

[HttpPut("{id}")]
public IActionResult UpdateProduct(
    [FromRoute] int id,
    [FromBody] Product product)       // FromBody - update data
{
    // Implementation
}
```

**Scenario 2: Complex Search**
```csharp
[HttpGet("search")]
public IActionResult SearchProducts(
    [FromQuery] ProductSearch filters) // Complex object from query string
{
    // MVC will bind ?category=electronics&minPrice=100&maxPrice=500
    // to ProductSearch object properties
}

public class ProductSearch
{
    public string Category { get; set; }
    public decimal? MinPrice { get; set; }
    public decimal? MaxPrice { get; set; }
}
```

## 2. Model Validation with DataAnnotations

### Basic Validation Attributes

```csharp
public class Product
{
    [Required(ErrorMessage = "Product ID is required")]
    public int Id { get; set; }

    [Required]
    [StringLength(100, MinimumLength = 3)]
    public string Name { get; set; }

    [Range(0.01, 10000.00)]
    public decimal Price { get; set; }

    [EmailAddress]
    public string SupplierEmail { get; set; }

    [Url]
    public string ProductUrl { get; set; }

    [RegularExpression(@"^[A-Z]{3}-\d{3}$")]
    public string ProductCode { get; set; }

    [Compare("EmailConfirmation")]
    public string Email { get; set; }
    
    public string EmailConfirmation { get; set; }
}
```

### Validation in Action Methods

```csharp
[HttpPost]
public IActionResult CreateProduct([FromBody] Product product)
{
    if (!ModelState.IsValid)
    {
        return BadRequest(ModelState);
    }
    
    var createdProduct = _service.CreateProduct(product);
    return CreatedAtAction(nameof(GetProduct), new { id = createdProduct.Id }, createdProduct);
}
```

### Custom Error Messages

```csharp
public class Product
{
    [Required(ErrorMessage = "{0} is required")]
    [StringLength(100, ErrorMessage = "{0} must be between {2} and {1} characters", MinimumLength = 3)]
    public string Name { get; set; }

    [Range(0.01, 10000.00, ErrorMessage = "{0} must be between {1} and {2}")]
    public decimal Price { get; set; }
}
```

## 3. Custom Validation Attributes and IValidatableObject

### Custom Validation Attribute

```csharp
public class FutureDateAttribute : ValidationAttribute
{
    public FutureDateAttribute() : base("{0} must be a future date") { }

    protected override ValidationResult IsValid(object value, ValidationContext validationContext)
    {
        if (value is DateTime dateValue)
        {
            if (dateValue <= DateTime.Now)
            {
                var errorMessage = FormatErrorMessage(validationContext.DisplayName);
                return new ValidationResult(errorMessage);
            }
        }
        return ValidationResult.Success;
    }
}

// Usage
public class Event
{
    [FutureDate]
    public DateTime EventDate { get; set; }
}
```

### Attribute with Dependency Injection

```csharp
public class UniqueProductNameAttribute : ValidationAttribute
{
    protected override ValidationResult IsValid(object value, ValidationContext validationContext)
    {
        var productService = (IProductService)validationContext.GetService(typeof(IProductService));
        
        if (productService.ProductNameExists(value?.ToString()))
        {
            return new ValidationResult("Product name already exists");
        }
        
        return ValidationResult.Success;
    }
}
```

### IValidatableObject Implementation

```csharp
public class Order : IValidatableObject
{
    public DateTime OrderDate { get; set; }
    public DateTime? DeliveryDate { get; set; }
    public List<OrderItem> Items { get; set; } = new();

    public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
    {
        // Cross-property validation
        if (DeliveryDate.HasValue && DeliveryDate <= OrderDate)
        {
            yield return new ValidationResult(
                "Delivery date must be after order date",
                new[] { nameof(DeliveryDate) });
        }

        // Business rule validation
        if (Items.Sum(item => item.Quantity) > 100)
        {
            yield return new ValidationResult(
                "Total quantity cannot exceed 100 items",
                new[] { nameof(Items) });
        }

        // Complex validation logic
        if (Items.Any(item => item.Quantity <= 0))
        {
            yield return new ValidationResult(
                "All items must have positive quantity",
                new[] { nameof(Items) });
        }
    }
}
```

## 4. ModelState Validation and Custom Model Binders

### ModelState Deep Dive

```csharp
[HttpPost]
public IActionResult CreateProduct(Product product)
{
    // Manual validation
    if (product.Price <= 0)
    {
        ModelState.AddModelError(nameof(product.Price), "Price must be positive");
    }

    // Check specific property errors
    if (ModelState.GetFieldValidationState(nameof(product.Name)) == ModelValidationState.Invalid)
    {
        // Handle name validation errors specifically
    }

    // Get all errors
    var errors = ModelState.Values
        .SelectMany(v => v.Errors)
        .Select(e => e.ErrorMessage)
        .ToList();

    if (!ModelState.IsValid)
    {
        // Custom error response
        var problemDetails = new ValidationProblemDetails(ModelState)
        {
            Type = "https://tools.ietf.org/html/rfc7231#section-6.5.1",
            Title = "One or more validation errors occurred."
        };
        
        return BadRequest(problemDetails);
    }

    return Ok();
}
```

### Custom Model Binder

```csharp
public class ProductModelBinder : IModelBinder
{
    public Task BindModelAsync(ModelBindingContext bindingContext)
    {
        if (bindingContext == null)
            throw new ArgumentNullException(nameof(bindingContext));

        var modelName = bindingContext.ModelName;
        var valueProviderResult = bindingContext.ValueProvider.GetValue(modelName);

        if (valueProviderResult == ValueProviderResult.None)
            return Task.CompletedTask;

        bindingContext.ModelState.SetModelValue(modelName, valueProviderResult);

        var value = valueProviderResult.FirstValue;
        if (string.IsNullOrEmpty(value))
            return Task.CompletedTask;

        // Custom parsing logic
        if (!int.TryParse(value, out var id))
        {
            bindingContext.ModelState.TryAddModelError(modelName, "Product Id must be an integer.");
            return Task.CompletedTask;
        }

        // Create product with additional context
        var httpContext = bindingContext.HttpContext;
        var product = new Product
        {
            Id = id,
            CreatedBy = httpContext.User.Identity.Name,
            CreatedAt = DateTime.UtcNow
        };

        bindingContext.Result = ModelBindingResult.Successful(product);
        return Task.CompletedTask;
    }
}

// Custom binder provider
public class ProductModelBinderProvider : IModelBinderProvider
{
    public IModelBinder GetBinder(ModelBinderProviderContext context)
    {
        if (context.Metadata.ModelType == typeof(Product))
            return new ProductModelBinder();

        return null;
    }
}

// Registration in Startup.cs
services.AddMvc(options =>
{
    options.ModelBinderProviders.Insert(0, new ProductModelBinderProvider());
});
```

### Custom Value Provider

```csharp
public class HeaderValueProvider : BindingSourceValueProvider
{
    private readonly IHeaderDictionary _headers;

    public HeaderValueProvider(BindingSource bindingSource, IHeaderDictionary headers) 
        : base(bindingSource)
    {
        _headers = headers;
    }

    public override bool ContainsPrefix(string prefix)
    {
        return _headers.ContainsKey(prefix);
    }

    public override ValueProviderResult GetValue(string key)
    {
        if (_headers.TryGetValue(key, out var values))
        {
            return new ValueProviderResult(values);
        }
        return ValueProviderResult.None;
    }
}
```

## 5. Dependency Injection and Configuration

### Configuration Binding

```csharp
public class DatabaseSettings
{
    public string ConnectionString { get; set; }
    public int Timeout { get; set; }
    public bool EnableLogging { get; set; }
}

// appsettings.json
{
  "DatabaseSettings": {
    "ConnectionString": "Server=localhost;Database=MyDb;",
    "Timeout": 30,
    "EnableLogging": true
  }
}

// Startup configuration
services.Configure<DatabaseSettings>(Configuration.GetSection("DatabaseSettings"));

// Usage in controller
public class ProductsController : Controller
{
    private readonly DatabaseSettings _dbSettings;

    public ProductsController(IOptions<DatabaseSettings> dbSettings)
    {
        _dbSettings = dbSettings.Value;
    }
}
```

### Validation with Dependency Injection

```csharp
public interface IProductValidator
{
    ValidationResult Validate(Product product);
}

public class ProductValidator : IProductValidator
{
    private readonly IProductRepository _repository;

    public ProductValidator(IProductRepository repository)
    {
        _repository = repository;
    }

    public ValidationResult Validate(Product product)
    {
        var results = new List<ValidationResult>();
        
        if (_repository.Exists(product.Name))
        {
            results.Add(new ValidationResult("Product name already exists"));
        }

        return new ValidationResult(results);
    }
}

// Registration
services.AddScoped<IProductValidator, ProductValidator>();

// Usage in controller
public class ProductsController : Controller
{
    private readonly IProductValidator _validator;

    public ProductsController(IProductValidator validator)
    {
        _validator = validator;
    }

    [HttpPost]
    public IActionResult CreateProduct([FromBody] Product product)
    {
        var validationResult = _validator.Validate(product);
        if (!validationResult.IsValid)
        {
            foreach (var error in validationResult.Errors)
            {
                ModelState.AddModelError("", error.ErrorMessage);
            }
            return BadRequest(ModelState);
        }
        
        // Process valid product
        return Ok();
    }
}
```

## Probable Questions and Answers

### Q1: What's the difference between [FromBody] and [FromForm]?

**Answer**: 
- `[FromBody]`: Used for JSON/XML data in request body, typically for APIs
- `[FromForm]`: Used for form data (application/x-www-form-urlencoded or multipart/form-data)

**When to use**:
- Use `[FromBody]` for REST APIs with JSON payloads
- Use `[FromForm]` for traditional HTML form submissions or file uploads

```csharp
// API endpoint
[HttpPost]
public IActionResult ApiCreate([FromBody] Product product)

// Form endpoint
[HttpPost]
public IActionResult FormCreate([FromForm] Product product)
```

### Q2: How does model binding handle null values?

**Answer**: 
- For value types (int, DateTime, etc.), default values are used if binding fails
- For nullable value types (int?, DateTime?), null is assigned if binding fails
- For reference types (string, custom classes), null is assigned

**Tricky Part**: Value types will never be null, so you might get unexpected default values instead of validation errors.

```csharp
public class Example
{
    public int RequiredInt { get; set; }        // Defaults to 0 if missing
    public int? OptionalInt { get; set; }       // Null if missing
    public string Name { get; set; }            // Null if missing
}
```

### Q3: What's the execution order of validation attributes?

**Answer**: Validation attributes execute in this order:
1. RequiredAttribute
2. RegularExpressionAttribute, StringLengthAttribute, RangeAttribute, etc.
3. Custom validation attributes
4. IValidatableObject.Validate() method

**Reasoning**: Required checks happen first because if a value is missing, other validations don't make sense.

### Q4: How to handle validation errors globally?

**Answer**: Use `ApiController` attribute or configure globally:

```csharp
// Automatic ModelState validation
[ApiController]
public class ProductsController : ControllerBase
{
    // ModelState.IsValid is automatically checked
}

// Or configure globally
services.Configure<ApiBehaviorOptions>(options =>
{
    options.SuppressModelStateInvalidFilter = false;
});
```

### Q5: When would you use a custom model binder vs validation attributes?

**Answer**: 
- **Custom Model Binder**: When you need to transform incoming data before binding (e.g., custom string formats, complex parsing logic)
- **Validation Attributes**: When you need to validate already-bound data according to business rules

**Example**: 
- Use custom binder for converting "YYYY-MM-DD" strings to DateTime
- Use validation attributes to ensure the date is in the future

### Q6: How to validate collections or complex nested objects?

**Answer**: Use validation attributes on collection items and nested objects:

```csharp
public class Order
{
    [Required]
    public string CustomerName { get; set; }

    [MinLength(1, ErrorMessage = "At least one item is required")]
    public List<OrderItem> Items { get; set; }
}

public class OrderItem
{
    [Required]
    public string ProductId { get; set; }
    
    [Range(1, 100)]
    public int Quantity { get; set; }
}
```

### Q7: What's the difference between ModelState.IsValid and TryValidateModel?

**Answer**: 
- `ModelState.IsValid`: Checks if there are any validation errors in the current ModelState
- `TryValidateModel(object model)`: Validates the specified model and updates ModelState

```csharp
var product = new Product();
if (TryValidateModel(product))
{
    // Model is valid
}
else
{
    // ModelState contains errors for the product
}
```

### Q8: How to handle validation in service layer vs controller?

**Answer**: 
- **Controller validation**: For input format validation (required fields, data types)
- **Service layer validation**: For business rules validation (unique constraints, complex logic)

```csharp
public class ProductsController : Controller
{
    [HttpPost]
    public IActionResult CreateProduct([FromBody] Product product)
    {
        // Input validation
        if (!ModelState.IsValid)
            return BadRequest(ModelState);
        
        // Business validation in service layer
        var result = _productService.Create(product);
        if (!result.Success)
        {
            foreach (var error in result.Errors)
            {
                ModelState.AddModelError("", error);
            }
            return BadRequest(ModelState);
        }
        
        return Ok(result.Product);
    }
}
```

### Q9: How to create conditional validation?

**Answer**: Use custom validation attributes or IValidatableObject:

```csharp
public class ConditionalRequiredAttribute : ValidationAttribute
{
    private readonly string _dependentProperty;

    public ConditionalRequiredAttribute(string dependentProperty)
    {
        _dependentProperty = dependentProperty;
    }

    protected override ValidationResult IsValid(object value, ValidationContext context)
    {
        var dependentProperty = context.ObjectType.GetProperty(_dependentProperty);
        var dependentValue = dependentProperty.GetValue(context.ObjectInstance);

        if (dependentValue?.ToString() == "SpecialCase" && value == null)
        {
            return new ValidationResult(ErrorMessage);
        }

        return ValidationResult.Success;
    }
}
```

### Q10: How to test model binding and validation?

**Answer**: Use unit tests with ModelState:

```csharp
[Test]
public void Product_WithInvalidPrice_ShouldFailValidation()
{
    // Arrange
    var product = new Product { Price = -10 };
    var controller = new ProductsController();
    
    // Act
    controller.ModelState.Clear();
    var result = controller.CreateProduct(product);
    
    // Assert
    Assert.IsFalse(controller.ModelState.IsValid);
    Assert.IsTrue(controller.ModelState.ContainsKey(nameof(product.Price)));
}
```

This comprehensive guide covers all aspects of model binding and validation in ASP.NET Core, providing both surface-level understanding and deep technical knowledge.
