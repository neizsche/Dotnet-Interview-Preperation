# C# Language Fundamentals - Deep Dive

## 1. Data Types and Variables

### Value Types vs Reference Types - Deep Understanding

**Core Concepts:**
```csharp
// VALUE TYPES (stored on stack)
int x = 10;         // Stack: x = 10
int y = x;          // Stack: y = 10 (COPY)
y = 20;             // Stack: y = 20, x remains 10

// REFERENCE TYPES (stored on heap)
class Person { public string Name; }
Person p1 = new Person { Name = "John" };  // Heap: object, Stack: reference
Person p2 = p1;                            // Stack: copy of reference
p2.Name = "Jane";                          // Both p1 and p2 see the change
```

**Memory Layout:**
```
STACK (Value Types)      HEAP (Reference Types)
┌──────────────┐        ┌──────────────────┐
│ int x = 10   │        │ Person Object    │
│ int y = 20   │        │ - Name = "Jane"  │
│ ref p1 ──────┼───────►│ ...              │
│ ref p2 ──────┘        └──────────────────┘
└──────────────┘
```

**Advanced Scenarios:**
```csharp
// Struct (value type) vs Class (reference type)
public struct Point { public int X, Y; }
public class Rectangle { public Point Location; }

var rect = new Rectangle { Location = new Point { X = 10, Y = 20 } };
var location = rect.Location;  // COPY of the struct
location.X = 30;               // rect.Location.X remains 10
```

### Probable Questions & Answers

**Q1: What happens when you pass a struct to a method? Does it get copied?**
```csharp
public void ModifyPoint(Point p) { p.X = 100; }

var point = new Point { X = 10, Y = 20 };
ModifyPoint(point);
Console.WriteLine(point.X); // Output: 10 (original unchanged)
```
**Answer:** Yes, structs are passed by value (copied). Use `ref` to pass by reference.

**Q2: Why can't structs have parameterless constructors in C#?**
**Answer:** Structs always have an implicit parameterless constructor that zero-initializes all fields. Allowing explicit ones could create inconsistency.

**Q3: What's the performance implication of large structs?**
**Answer:** Large structs cause expensive copies. Guideline: keep structs under 16-24 bytes.

**Q4: Can value types contain reference types?**
```csharp
public struct DataContainer 
{ 
    public string Name;  // Reference type in value type
    public int Value;
}
```
**Answer:** Yes, but the reference is stored on the stack pointing to heap data.

---

## 2. Built-in Types Deep Dive

### Numeric Types Precision
```csharp
// INTEGER TYPES
byte  (1 byte): 0 to 255
sbyte (1 byte): -128 to 127
short (2 bytes): -32,768 to 32,767
ushort(2 bytes): 0 to 65,535
int   (4 bytes): ±2.1 billion
long  (8 bytes): ±9.2 quintillion

// FLOATING POINT (IEEE 754)
float  (4 bytes): ~6-9 digits precision, suffix 'f'
double (8 bytes): ~15-17 digits precision, default
decimal(16 bytes): 28-29 digits precision, financial, suffix 'm'

// PRECISION ISSUES
float f = 0.1f + 0.2f;        // 0.30000001192092896
double d = 0.1 + 0.2;         // 0.30000000000000004  
decimal m = 0.1m + 0.2m;      // 0.3 (exact)
```

### DateTime Deep Dive
```csharp
// DATETIME KINDS
DateTime local = DateTime.Now;        // Local time
DateTime utc = DateTime.UtcNow;       // UTC time
DateTime unspecified = new DateTime(2023, 1, 1); // Unspecified

// TICKS RESOLUTION
DateTime dt = DateTime.Now;
long ticks = dt.Ticks; // 100-nanosecond intervals since 1/1/0001

// DATETIME vs DATETIMEOFFSET
DateTime dt = new DateTime(2023, 1, 1); // No timezone info
DateTimeOffset dto = DateTimeOffset.Now; // Includes offset from UTC
```

### Probable Questions & Answers

**Q1: Why should you use decimal for financial calculations?**
**Answer:** decimal uses base-10 floating point, avoiding binary representation errors that affect float/double with decimal fractions.

**Q2: What's the difference between DateTime.Kind Unspecified, Local, and Utc?**
**Answer:** 
- Unspecified: No timezone information (dangerous for conversions)
- Local: Machine's local timezone
- Utc: Coordinated Universal Time

**Q3: When would you use DateTimeOffset instead of DateTime?**
**Answer:** When working with multiple timezones or storing absolute points in time. DateTimeOffset preserves the offset information.

**Q4: What's the maximum value of DateTime and what happens after?**
```csharp
DateTime max = DateTime.MaxValue; // December 31, 9999
// DateTime.MaxValue.AddTicks(1) throws OverflowException
```

---

## 3. Nullable Value Types

### Deep Implementation
```csharp
// NULLABLE<T> STRUCT INTERNAL (conceptual)
public struct Nullable<T> where T : struct
{
    private readonly T value;
    private readonly bool hasValue;
    
    public T Value => hasValue ? value : throw new InvalidOperationException();
    public bool HasValue => hasValue;
}

// SYNTAX SUGAR
int? nullableInt = null;        // Equivalent to Nullable<int>
int regularInt = nullableInt.Value; // Throws if null
```

### Advanced Patterns
```csharp
// NULL COALESCING WITH NULLABLES
int? maybeNumber = null;
int result = maybeNumber ?? 10; // 10

// NULLABLE PATTERN MATCHING
if (maybeNumber is int number)
{
    Console.WriteLine(number);
}

// NULLABLE HASHCODE CONSIDERATIONS
int? a = null;
int? b = null;
Console.WriteLine(a.GetHashCode() == b.GetHashCode()); // True
```

### Probable Questions & Answers

**Q1: What's the difference between `int?` and `Nullable<int>`?**
**Answer:** They're identical. `int?` is syntactic sugar for `Nullable<int>`.

**Q2: Can you have `Nullable<Nullable<int>>`?**
**Answer:** No, the type parameter must be a non-nullable value type.

**Q3: How does boxing work with nullable types?**
```csharp
int? nullable = 42;
object boxed = nullable; // Boxes the underlying int, not Nullable<int>
Console.WriteLine(boxed.GetType()); // System.Int32

int? nullValue = null;
object nullBoxed = nullValue; // Results in null reference
```

**Q4: What happens when you call GetType() on a nullable with value?**
```csharp
int? number = 42;
Console.WriteLine(number.GetType()); // System.Int32 (not Nullable<Int32>)
```

---

## 4. var Keyword and Type Inference

### Compiler Implementation
```csharp
// COMPILER INFERENCE PROCESS
var name = "John";          // Compiler: string name = "John";
var count = 10;             // Compiler: int count = 10;
var list = new List<int>(); // Compiler: List<int> list = new List<int>();

// WHAT VAR IS NOT
// var x;                   // ERROR: must be initialized
// var y = null;            // ERROR: can't infer type from null
// var z = GetData();       // OK if return type is known at compile time
```

### Advanced Scenarios
```csharp
// ANONYMOUS TYPES REQUIRE VAR
var person = new { Name = "John", Age = 30 }; // Compiler-generated type

// CAPTURED VARIABLES IN LAMBDAS
var numbers = new List<int> { 1, 2, 3 };
var multiplier = 2; // Type inferred as int
var result = numbers.Select(x => x * multiplier); // multiplier captured

// TYPE INFERENCE WITH GENERICS
var dictionary = new Dictionary<string, List<int>>(); // Complex type inferred
```

### Probable Questions & Answers

**Q1: Does using `var` affect performance?**
**Answer:** No, it's purely compile-time. The generated IL is identical to explicit typing.

**Q2: When should you avoid using `var`?**
**Answer:** 
- When the type isn't obvious from the right-hand side
- For primitive types where explicit typing improves readability
- When you want to specify an interface type explicitly

**Q3: What happens with `var` and inheritance?**
```csharp
IEnumerable<int> numbers = new List<int>(); // Type is IEnumerable<int>
var numbersVar = new List<int>();           // Type is List<int>
```

**Q4: Can `var` be used in method parameters or return types?**
**Answer:** No, `var` is only for local variable type inference.

---

## 5. Dynamic Typing (dynamic keyword)

### DLR (Dynamic Language Runtime) Integration
```csharp
// DYNAMIC VS VAR
var name = "John";     // Compile-time type: string (static typing)
dynamic data = "John"; // Runtime type resolution (dynamic typing)

// DYNAMIC METHOD DISPATCH
dynamic obj = GetSomeObject();
obj.SomeMethod(); // Resolution deferred to runtime

// COMPILER GENERATED CODE (conceptual)
// dynamic call becomes: 
// Microsoft.CSharp.RuntimeBinder.Binder.InvokeMember(...)
```

### Advanced Dynamic Scenarios
```csharp
// DYNAMIC WITH EXPANDOOBJECT
dynamic person = new ExpandoObject();
person.Name = "John";      // Adds property at runtime
person.Age = 30;           // Adds another property
person.SayHello = (Action)(() => Console.WriteLine("Hello")); // Adds method

// DYNAMIC OPERATOR OVERLOADING
dynamic x = 10;
dynamic y = 20;
dynamic result = x + y; // Runtime operator resolution

// DYNAMIC WITH COM INTEROP
dynamic excelApp = Microsoft.VisualBasic.Interaction.GetObject("Excel.Application");
excelApp.Visible = true; // Late-bound COM calls
```

### Performance Implications
```csharp
// DLR CACHING MECHANISM
// First call to a dynamic member: slow (resolution + cache)
// Subsequent calls: faster (using cache)

// BOXING WITH DYNAMIC
dynamic number = 42;        // int boxed to object
int result = number + 10;   // Unboxing + operation
```

### Probable Questions & Answers

**Q1: What's the difference between `dynamic` and `object`?**
```csharp
object obj = "hello";
// obj.Length; // COMPILE ERROR: object doesn't have Length

dynamic dyn = "hello";
int length = dyn.Length; // RUNTIME: resolves successfully
```

**Q2: When would you use `dynamic` in real applications?**
**Answer:** 
- COM interop with Office applications
- Working with JSON data without POCO classes
- Duck typing scenarios
- Reflection simplification (but consider `dynamic` vs proper reflection)

**Q3: What exceptions can `dynamic` throw?**
**Answer:** `RuntimeBinderException` when members don't exist or operations are invalid.

**Q4: How does `dynamic` work with inheritance?**
```csharp
class Base { public void Method() { } }
class Derived : Base { public void NewMethod() { } }

dynamic obj = new Derived();
obj.Method();    // Works (inherited)
obj.NewMethod(); // Works (defined on derived)
obj.Unknown();   // RuntimeBinderException
```

---

## 6. Operators and Expressions

### Operator Precedence Deep Dive
```csharp
// PRECEDENCE HIERARCHY (high to low)
// Primary: x.y, f(x), a[x], x++, x--, new, typeof, checked, unchecked
// Unary: +, -, !, ~, ++x, --x, (T)x, await
// Multiplicative: *, /, %
// Additive: +, -
// Shift: <<, >>
// Relational: <, >, <=, >=, is, as
// Equality: ==, !=
// Logical AND: &
// Logical XOR: ^
// Logical OR: |
// Conditional AND: &&
// Conditional OR: ||
// Null coalescing: ??
// Conditional: ?:
// Assignment: =, +=, -=, etc.

// COMPLEX EXPRESSION
var result = a + b * c ?? d is string ? e : f;
// Equivalent to: (a + (b * c)) ?? (d is string ? e : f)
```

### Custom Operator Overloading
```csharp
public struct Vector
{
    public double X, Y;
    
    public static Vector operator +(Vector a, Vector b) 
        => new Vector { X = a.X + b.X, Y = a.Y + b.Y };
    
    public static bool operator ==(Vector a, Vector b) 
        => a.X == b.X && a.Y == b.Y;
    
    public static bool operator !=(Vector a, Vector b) 
        => !(a == b);
    
    // Must override Equals and GetHashCode when overloading ==
    public override bool Equals(object obj) => obj is Vector v && this == v;
    public override int GetHashCode() => HashCode.Combine(X, Y);
}
```

### Tricky Operator Questions

**Q1: What's the difference between `x++` and `++x`?**
```csharp
int x = 5;
int a = x++; // a = 5, x = 6 (post-increment)
int b = ++x; // b = 7, x = 7 (pre-increment)
```

**Q2: How does the null-conditional operator short-circuit?**
```csharp
Person person = null;
string name = person?.Address?.City; // Entire expression returns null
// Equivalent to: person == null ? null : person.Address?.City
```

**Q3: What's the behavior of nullable equality operators?**
```csharp
int? a = null;
int? b = null;
int? c = 5;

Console.WriteLine(a == b); // True (both null)
Console.WriteLine(a == c); // False (null vs value)
Console.WriteLine(a > c);  // False (any comparison with null returns false)
```

**Q4: How does operator lifting work with nullables?**
```csharp
int? a = 10;
int? b = 20;
int? result = a + b; // 30 (operators "lifted" to work with nullables)

int? nullValue = null;
int? test = nullValue + 10; // null (any operation with null returns null)
```

**Q5: What's the difference between `&` and `&&`?**
```csharp
bool Method1() { Console.Write("1"); return false; }
bool Method2() { Console.Write("2"); return true; }

bool result1 = Method1() & Method2();  // Output: "12" (both evaluated)
bool result2 = Method1() && Method2(); // Output: "1" (short-circuited)
```

This deep dive covers the fundamental concepts, implementation details, and tricky scenarios you'll encounter in interviews. Practice these patterns and understand the "why" behind each behavior.
