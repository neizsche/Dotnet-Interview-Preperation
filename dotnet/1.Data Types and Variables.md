	# C# Language Fundamentals - Deep Dive

## 1. Data Types and Variables

### Value Types vs Reference Types - Deep Understanding

**Core Concepts:**
```csharp
// VALUE TYPES (stored on stack)
int x = 10;         // Stack: x = 10
int y = x;          // Stack: y = 10 (COPY)
y = 20;             // Stack: y = 20, x remains 10

// REFERENCE TYPES (stored on heap)
class Person { public string Name; }
Person p1 = new Person { Name = "John" };  // Heap: object, Stack: reference
Person p2 = p1;                            // Stack: copy of reference
p2.Name = "Jane";                          // Both p1 and p2 see the change
```

**Memory Layout:**
```
STACK (Value Types)      HEAP (Reference Types)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ int x = 10   ‚îÇ        ‚îÇ Person Object    ‚îÇ
‚îÇ int y = 20   ‚îÇ        ‚îÇ - Name = "Jane"  ‚îÇ
‚îÇ ref p1 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ ...              ‚îÇ
‚îÇ ref p2 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Advanced Scenarios:**
```csharp
// Struct (value type) vs Class (reference type)
public struct Point { public int X, Y; }
public class Rectangle { public Point Location; }

var rect = new Rectangle { Location = new Point { X = 10, Y = 20 } };
var location = rect.Location;  // COPY of the struct
location.X = 30;               // rect.Location.X remains 10
```

### Probable Questions & Answers

**Q1: What happens when you pass a struct to a method? Does it get copied?**
```csharp
public void ModifyPoint(Point p) { p.X = 100; }

var point = new Point { X = 10, Y = 20 };
ModifyPoint(point);
Console.WriteLine(point.X); // Output: 10 (original unchanged)
```
**Answer:** Yes, structs are passed by value (copied). Use `ref` to pass by reference.

**Q2: Why can't structs have parameterless constructors in C#?**
**Answer:** Structs always have an implicit parameterless constructor that zero-initializes all fields. Allowing explicit ones could create inconsistency.

**Q3: What's the performance implication of large structs?**
**Answer:** Large structs cause expensive copies. Guideline: keep structs under 16-24 bytes.

**Q4: Can value types contain reference types?**
```csharp
public struct DataContainer 
{ 
    public string Name;  // Reference type in value type
    public int Value;
}
```
**Answer:** Yes, but the reference is stored on the stack pointing to heap data.

---

## 2. Built-in Types Deep Dive

### Numeric Types Precision
```csharp
// INTEGER TYPES
byte  (1 byte): 0 to 255
sbyte (1 byte): -128 to 127
short (2 bytes): -32,768 to 32,767
ushort(2 bytes): 0 to 65,535
int   (4 bytes): ¬±2.1 billion
long  (8 bytes): ¬±9.2 quintillion

// FLOATING POINT (IEEE 754)
float  (4 bytes): ~6-9 digits precision, suffix 'f'
double (8 bytes): ~15-17 digits precision, default
decimal(16 bytes): 28-29 digits precision, financial, suffix 'm'

// PRECISION ISSUES
float f = 0.1f + 0.2f;        // 0.30000001192092896
double d = 0.1 + 0.2;         // 0.30000000000000004  
decimal m = 0.1m + 0.2m;      // 0.3 (exact)
```

### DateTime Deep Dive
```csharp
// DATETIME KINDS
DateTime local = DateTime.Now;        // Local time
DateTime utc = DateTime.UtcNow;       // UTC time
DateTime unspecified = new DateTime(2023, 1, 1); // Unspecified

// TICKS RESOLUTION
DateTime dt = DateTime.Now;
long ticks = dt.Ticks; // 100-nanosecond intervals since 1/1/0001

// DATETIME vs DATETIMEOFFSET
DateTime dt = new DateTime(2023, 1, 1); // No timezone info
DateTimeOffset dto = DateTimeOffset.Now; // Includes offset from UTC
```

### Probable Questions & Answers

**Q1: Why should you use decimal for financial calculations?**
**Answer:** decimal uses base-10 floating point, avoiding binary representation errors that affect float/double with decimal fractions.

**Q2: What's the difference between DateTime.Kind Unspecified, Local, and Utc?**
**Answer:** 
- Unspecified: No timezone information (dangerous for conversions)
- Local: Machine's local timezone
- Utc: Coordinated Universal Time

**Q3: When would you use DateTimeOffset instead of DateTime?**
**Answer:** When working with multiple timezones or storing absolute points in time. DateTimeOffset preserves the offset information.

**Q4: What's the maximum value of DateTime and what happens after?**
```csharp
DateTime max = DateTime.MaxValue; // December 31, 9999
// DateTime.MaxValue.AddTicks(1) throws OverflowException
```

---

## 3. Nullable Value Types

### Deep Implementation
```csharp
// NULLABLE<T> STRUCT INTERNAL (conceptual)
public struct Nullable<T> where T : struct
{
    private readonly T value;
    private readonly bool hasValue;
    
    public T Value => hasValue ? value : throw new InvalidOperationException();
    public bool HasValue => hasValue;
}

// SYNTAX SUGAR
int? nullableInt = null;        // Equivalent to Nullable<int>
int regularInt = nullableInt.Value; // Throws if null
```

### Advanced Patterns
```csharp
// NULL COALESCING WITH NULLABLES
int? maybeNumber = null;
int result = maybeNumber ?? 10; // 10

// NULLABLE PATTERN MATCHING
if (maybeNumber is int number)
{
    Console.WriteLine(number);
}

// NULLABLE HASHCODE CONSIDERATIONS
int? a = null;
int? b = null;
Console.WriteLine(a.GetHashCode() == b.GetHashCode()); // True
```

### Probable Questions & Answers

**Q1: What's the difference between `int?` and `Nullable<int>`?**
**Answer:** They're identical. `int?` is syntactic sugar for `Nullable<int>`.

**Q2: Can you have `Nullable<Nullable<int>>`?**
**Answer:** No, the type parameter must be a non-nullable value type.

**Q3: How does boxing work with nullable types?**
```csharp
int? nullable = 42;
object boxed = nullable; // Boxes the underlying int, not Nullable<int>
Console.WriteLine(boxed.GetType()); // System.Int32

int? nullValue = null;
object nullBoxed = nullValue; // Results in null reference
```

**Q4: What happens when you call GetType() on a nullable with value?**
```csharp
int? number = 42;
Console.WriteLine(number.GetType()); // System.Int32 (not Nullable<Int32>)
```

---

## 4. var Keyword and Type Inference

### Compiler Implementation
```csharp
// COMPILER INFERENCE PROCESS
var name = "John";          // Compiler: string name = "John";
var count = 10;             // Compiler: int count = 10;
var list = new List<int>(); // Compiler: List<int> list = new List<int>();

// WHAT VAR IS NOT
// var x;                   // ERROR: must be initialized
// var y = null;            // ERROR: can't infer type from null
// var z = GetData();       // OK if return type is known at compile time
```

### Advanced Scenarios
```csharp
// ANONYMOUS TYPES REQUIRE VAR
var person = new { Name = "John", Age = 30 }; // Compiler-generated type

// CAPTURED VARIABLES IN LAMBDAS
var numbers = new List<int> { 1, 2, 3 };
var multiplier = 2; // Type inferred as int
var result = numbers.Select(x => x * multiplier); // multiplier captured

// TYPE INFERENCE WITH GENERICS
var dictionary = new Dictionary<string, List<int>>(); // Complex type inferred
```

### Probable Questions & Answers

**Q1: Does using `var` affect performance?**
**Answer:** No, it's purely compile-time. The generated IL is identical to explicit typing.

**Q2: When should you avoid using `var`?**
**Answer:** 
- When the type isn't obvious from the right-hand side
- For primitive types where explicit typing improves readability
- When you want to specify an interface type explicitly

**Q3: What happens with `var` and inheritance?**
```csharp
IEnumerable<int> numbers = new List<int>(); // Type is IEnumerable<int>
var numbersVar = new List<int>();           // Type is List<int>
```

**Q4: Can `var` be used in method parameters or return types?**
**Answer:** No, `var` is only for local variable type inference.

---

## 5. Dynamic Typing (dynamic keyword)

### DLR (Dynamic Language Runtime) Integration
```csharp
// DYNAMIC VS VAR
var name = "John";     // Compile-time type: string (static typing)
dynamic data = "John"; // Runtime type resolution (dynamic typing)

// DYNAMIC METHOD DISPATCH
dynamic obj = GetSomeObject();
obj.SomeMethod(); // Resolution deferred to runtime

// COMPILER GENERATED CODE (conceptual)
// dynamic call becomes: 
// Microsoft.CSharp.RuntimeBinder.Binder.InvokeMember(...)
```

### Advanced Dynamic Scenarios
```csharp
// DYNAMIC WITH EXPANDOOBJECT
dynamic person = new ExpandoObject();
person.Name = "John";      // Adds property at runtime
person.Age = 30;           // Adds another property
person.SayHello = (Action)(() => Console.WriteLine("Hello")); // Adds method

// DYNAMIC OPERATOR OVERLOADING
dynamic x = 10;
dynamic y = 20;
dynamic result = x + y; // Runtime operator resolution

// DYNAMIC WITH COM INTEROP
dynamic excelApp = Microsoft.VisualBasic.Interaction.GetObject("Excel.Application");
excelApp.Visible = true; // Late-bound COM calls
```

### Performance Implications
```csharp
// DLR CACHING MECHANISM
// First call to a dynamic member: slow (resolution + cache)
// Subsequent calls: faster (using cache)

// BOXING WITH DYNAMIC
dynamic number = 42;        // int boxed to object
int result = number + 10;   // Unboxing + operation
```

### Probable Questions & Answers

**Q1: What's the difference between `dynamic` and `object`?**
```csharp
object obj = "hello";
// obj.Length; // COMPILE ERROR: object doesn't have Length

dynamic dyn = "hello";
int length = dyn.Length; // RUNTIME: resolves successfully
```

**Q2: When would you use `dynamic` in real applications?**
**Answer:** 
- COM interop with Office applications
- Working with JSON data without POCO classes
- Duck typing scenarios
- Reflection simplification (but consider `dynamic` vs proper reflection)

**Q3: What exceptions can `dynamic` throw?**
**Answer:** `RuntimeBinderException` when members don't exist or operations are invalid.

**Q4: How does `dynamic` work with inheritance?**
```csharp
class Base { public void Method() { } }
class Derived : Base { public void NewMethod() { } }

dynamic obj = new Derived();
obj.Method();    // Works (inherited)
obj.NewMethod(); // Works (defined on derived)
obj.Unknown();   // RuntimeBinderException
```

---

## 6. Operators and Expressions

### Operator Precedence Deep Dive
```csharp
// PRECEDENCE HIERARCHY (high to low)
// Primary: x.y, f(x), a[x], x++, x--, new, typeof, checked, unchecked
// Unary: +, -, !, ~, ++x, --x, (T)x, await
// Multiplicative: *, /, %
// Additive: +, -
// Shift: <<, >>
// Relational: <, >, <=, >=, is, as
// Equality: ==, !=
// Logical AND: &
// Logical XOR: ^
// Logical OR: |
// Conditional AND: &&
// Conditional OR: ||
// Null coalescing: ??
// Conditional: ?:
// Assignment: =, +=, -=, etc.

// COMPLEX EXPRESSION
var result = a + b * c ?? d is string ? e : f;
// Equivalent to: (a + (b * c)) ?? (d is string ? e : f)
```

### Custom Operator Overloading
```csharp
public struct Vector
{
    public double X, Y;
    
    public static Vector operator +(Vector a, Vector b) 
        => new Vector { X = a.X + b.X, Y = a.Y + b.Y };
    
    public static bool operator ==(Vector a, Vector b) 
        => a.X == b.X && a.Y == b.Y;
    
    public static bool operator !=(Vector a, Vector b) 
        => !(a == b);
    
    // Must override Equals and GetHashCode when overloading ==
    public override bool Equals(object obj) => obj is Vector v && this == v;
    public override int GetHashCode() => HashCode.Combine(X, Y);
}
```

### Tricky Operator Questions

**Q1: What's the difference between `x++` and `++x`?**
```csharp
int x = 5;
int a = x++; // a = 5, x = 6 (post-increment)
int b = ++x; // b = 7, x = 7 (pre-increment)
```

**Q2: How does the null-conditional operator short-circuit?**
```csharp
Person person = null;
string name = person?.Address?.City; // Entire expression returns null
// Equivalent to: person == null ? null : person.Address?.City
```

**Q3: What's the behavior of nullable equality operators?**
```csharp
int? a = null;
int? b = null;
int? c = 5;

Console.WriteLine(a == b); // True (both null)
Console.WriteLine(a == c); // False (null vs value)
Console.WriteLine(a > c);  // False (any comparison with null returns false)
```

**Q4: How does operator lifting work with nullables?**
```csharp
int? a = 10;
int? b = 20;
int? result = a + b; // 30 (operators "lifted" to work with nullables)

int? nullValue = null;
int? test = nullValue + 10; // null (any operation with null returns null)
```

**Q5: What's the difference between `&` and `&&`?**
```csharp
bool Method1() { Console.Write("1"); return false; }
bool Method2() { Console.Write("2"); return true; }

bool result1 = Method1() & Method2();  // Output: "12" (both evaluated)
bool result2 = Method1() && Method2(); // Output: "1" (short-circuited)
```

This deep dive covers the fundamental concepts, implementation details, and tricky scenarios you'll encounter in interviews. Practice these patterns and understand the "why" behind each behavior.
It looks like you‚Äôre asking about the difference between dynamic and var in .NET (which you wrote as ‚Äúditnet‚Äù ‚Äî likely a typo). These are both keywords in C# used for declaring variables, but they behave very differently.

‚∏ª

‚úÖ Quick Summary

Feature	var	dynamic
Type Resolution	At compile time	At runtime
IDE IntelliSense	Full support (shows members)	Limited or none
Errors Caught	At compile time	Only at runtime
Use Case	When type is clear or inferred	When type is unknown until runtime (e.g., from JSON, COM, reflection)


‚∏ª

üîç var
	‚Ä¢	Type-safe: The compiler infers the type based on the right-hand side.
	‚Ä¢	Compile-time checking: You get IntelliSense, type checking, and early error detection.
	‚Ä¢	Cannot be null or uninitialized: The compiler must be able to infer the type.

Example:

var name = "Alice";  // inferred as string
var age = 30;        // inferred as int

Trying this:

var something = null;  // ‚ùå Compile-time error


‚∏ª

üîç dynamic
	‚Ä¢	Runtime-bound: The compiler skips type checking, and the actual type is resolved at runtime.
	‚Ä¢	Can be dangerous: Errors only show up during execution, not at compile time.
	‚Ä¢	Useful for interop with dynamic languages, reflection, COM objects, or dynamic JSON objects.

Example:

dynamic something = "Hello";
Console.WriteLine(something.Length);  // OK

something = 123;
Console.WriteLine(something.Length);  // ‚ùå Runtime error: int has no Length


‚∏ª

üß† When to Use What
	‚Ä¢	‚úÖ Use var when the type is known or easily inferred and you want safety.
	‚Ä¢	‚úÖ Use dynamic only when you must defer type checking to runtime.

‚∏ª

‚ö†Ô∏è Key Point

Both var and dynamic are not types themselves:
	‚Ä¢	var is syntactic sugar ‚Äî the real type is determined at compile time.
	‚Ä¢	dynamic is a real type ‚Äî basically an alias for object, but with runtime binding.

‚∏ª
Great ‚Äî let‚Äôs break down the difference between dynamic and object in C#.

They seem similar because both can hold any type of data, but how they behave ‚Äî especially in terms of type checking and method resolution ‚Äî is very different.

‚∏ª

‚úÖ Quick Summary

Feature	object	dynamic
Type Checking	Compile-time	Runtime
Member Access	Needs casting	No casting needed
IntelliSense Support	‚ùå Limited or none (needs cast)	‚ùå None (compiler defers checking)
Error Detection	Compile-time	Runtime only
Performance	Faster	Slower (due to runtime binding)
Use Case	Generic containers, base type	Dynamic JSON, COM interop, scripting APIs


‚∏ª

üîç object
	‚Ä¢	Base type of all types in .NET.
	‚Ä¢	You can store anything in an object, but to use it, you typically need to cast it back to the original type.

Example:

object obj = "hello";

// Console.WriteLine(obj.Length); ‚ùå Compile-time error
Console.WriteLine(((string)obj).Length);  // ‚úÖ Must cast

	‚Ä¢	The compiler doesn‚Äôt know what‚Äôs inside obj unless you cast it.
	‚Ä¢	Good for general-purpose containers, but not convenient when accessing members.

‚∏ª

üîç dynamic
	‚Ä¢	Internally treated like object, but with runtime type resolution.
	‚Ä¢	You don‚Äôt need to cast before using its members ‚Äî compiler defers all checking to runtime.

Example:

dynamic d = "hello";
Console.WriteLine(d.Length);  // ‚úÖ No cast needed

d = 10;
Console.WriteLine(d.Length);  // ‚ùå Runtime error (int has no Length)

	‚Ä¢	You trade compile-time safety for runtime flexibility.
	‚Ä¢	Great when working with:
	‚Ä¢	Dynamic JSON (e.g., via Newtonsoft.Json)
	‚Ä¢	COM objects
	‚Ä¢	Reflection-heavy libraries
	‚Ä¢	Duck typing

‚∏ª

üß† Key Differences Illustrated

object obj = "hello";
Console.WriteLine(obj.Length);        // ‚ùå Compile-time error

dynamic d = "hello";
Console.WriteLine(d.Length);          // ‚úÖ Works (checked at runtime)


‚∏ª

‚ö†Ô∏è Warning
	‚Ä¢	dynamic bypasses compile-time safety ‚Äî so:
	‚Ä¢	Fewer errors at compile time
	‚Ä¢	More risk of runtime exceptions
	‚Ä¢	object requires explicit handling but gives better compiler support

‚∏ª

‚úÖ When to Use

Situation	Use object	Use dynamic
Generic data container	‚úÖ Yes	Maybe, but overkill
Accessing members/methods	‚ùå Needs cast	‚úÖ Easier access
Working with unknown structures (e.g. JSON)	‚ùå Clumsy	‚úÖ Ideal
Performance-sensitive code	‚úÖ Preferable	‚ùå Avoid if possible


‚∏ª

Great question ‚Äî & and && are both logical/bitwise operators in C#, but they have different behavior and use cases.

‚∏ª

‚úÖ Quick Summary

Operator	Name	Use With	Short-Circuit?	Common Use
&	Bitwise AND / Logical AND	Booleans or integers	‚ùå No	Bitwise operations or full boolean eval
&&	Logical AND (short-circuit)	Booleans only	‚úÖ Yes	Boolean conditions in if, while, etc.


‚∏ª

üîç Detailed Explanation

1. && ‚Äî Logical AND (Short-Circuit)
	‚Ä¢	Only works with boolean values.
	‚Ä¢	If the first operand is false, the second is NOT evaluated.
	‚Ä¢	Prevents unnecessary or dangerous evaluation.

Example:

bool A = false;
bool B = true;

if (A && B)
{
    // Won't execute, because A is false (short-circuits)
}

Why use &&?

if (obj != null && obj.SomeProperty == 5)
{
    // Safe: won't throw NullReferenceException
}

If you used & here instead, and obj was null, it would still evaluate obj.SomeProperty and crash.

‚∏ª

2. & ‚Äî Bitwise AND (also Logical AND, but no short-circuit)

a) Boolean context
	‚Ä¢	Works like &&, but always evaluates both sides, even if the first is false.

bool A = false;
bool B = true;

if (A & B)
{
    // Still false, but B is evaluated anyway
}

b) Bitwise context
	‚Ä¢	Operates on bits when used with integers.

int x = 5;      // 0101
int y = 3;      // 0011
int z = x & y;  // 0001 => 1


‚∏ª

üß† Summary Use Case Tips
	‚Ä¢	‚úÖ Use && for boolean logic in conditions (if/while), where short-circuiting is beneficial.
	‚Ä¢	‚úÖ Use & for bitwise operations or when you need to force both sides to evaluate (rare in boolean logic).

‚∏ª

Absolutely! Let‚Äôs do a side-by-side breakdown of | vs ||, just like we did for & vs &&.

‚∏ª

‚úÖ Quick Summary

Operator	Name	Use With	Short-Circuit?	Common Use
`	`	Bitwise OR / Logical OR	Booleans or integers	‚ùå No
`		`	Logical OR (short-circuit)	Booleans only


‚∏ª

üîç Detailed Explanation

1. || ‚Äî Logical OR (Short-Circuit)
	‚Ä¢	Boolean-only.
	‚Ä¢	If the first operand is true, the second operand is skipped.
	‚Ä¢	Used for efficiency and safety in conditions.

Example:

bool A = true;
bool B = false;

if (A || B)
{
    // Executes because A is true; B is NOT evaluated
}

Practical Use:

if (user == null || user.IsDisabled)
{
    // Safe: won't throw NullReferenceException
}


‚∏ª

2. | ‚Äî Bitwise OR / Logical OR (non-short-circuit)

a) Boolean context
	‚Ä¢	Like ||, but both sides are always evaluated, even if the first is true.

bool A = true;
bool B = false;

if (A | B)
{
    // Still true, but B is evaluated anyway
}

b) Bitwise context
	‚Ä¢	Works on the binary representation of integers.

int x = 5;      // 0101
int y = 3;      // 0011
int z = x | y;  // 0111 => 7


‚∏ª

‚ö†Ô∏è Key Differences

| Feature                        | ||            | |              |
|‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äì‚Äì|‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî|‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî|
| Short-circuit evaluation       | ‚úÖ Yes           | ‚ùå No             |
| Works with integers (bitwise) | ‚ùå No            | ‚úÖ Yes            |
| Safer in null/logic checks     | ‚úÖ Often safer   | ‚ùå Might throw if second side fails |

‚∏ª

üß† Use Case Tips
	‚Ä¢	‚úÖ Use || for regular boolean logic in control flow, like if, while.
	‚Ä¢	‚úÖ Use | for:
	‚Ä¢	Bitwise operations
	‚Ä¢	When both boolean expressions must be evaluated (rare)
	‚Ä¢	Working with flags/enums

‚∏ª

Bonus: Enums & Bit Flags

| is commonly used with enums marked with [Flags]:

[Flags]
enum FileAccess {
    Read = 1,
    Write = 2,
    Execute = 4
}

var permissions = FileAccess.Read | FileAccess.Write;

bool canWrite = (permissions & FileAccess.Write) != 0;


‚∏ª

